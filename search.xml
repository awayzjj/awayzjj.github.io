<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[leetcode排序整理]]></title>
    <url>%2F2021%2F04%2F18%2Fleetcode%E6%8E%92%E5%BA%8F%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[前言本文总结常见排序算法的实现和复杂度，记录排序相关的典型的leetcode题目。 常见排序算法的复杂度 常见排序算法的实现#### 912. 排序数组 难度中等182收藏分享切换为英文接收动态反馈 给你一个整数数组 nums，请你将该数组升序排列。 选择排序1234567891011121314151617181920class Solution &#123;public: vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); for (int i = 0; i &lt; len; i++) &#123; int minIndex = i; for (int j = i + 1; j &lt; len; j++) &#123; if (nums[j] &lt; nums[minIndex]) &#123; minIndex = j; &#125; &#125; swap(nums[i], nums[minIndex]); &#125; return nums; &#125;&#125;;// 思路：每一轮从无序区中选择最小的元素，放在有序区的后面（即无序区的开头）。比较得多，交换得少// 时间复杂度：O(N^2)// 空间复杂度：O(1)// 不稳定（有交换操作） 插入排序1234567891011121314151617181920class Solution &#123;public: vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); for (int i = 0; i &lt; len; i++) &#123; int j = i; int temp = nums[i]; while (j &gt; 0 &amp;&amp; nums[j - 1] &gt; temp) &#123; nums[j] = nums[j - 1]; // 向后退一格 j--; // 给nums[i]留出可能要插入的位置 &#125; nums[j] = temp; &#125; return nums; &#125;&#125;;// 思路：每一轮把无序区的第一个元素插入到有序区中。比较得少，交换得多。// 时间复杂度：O(n^2)// 空间复杂度：O(1)// 稳定（并没有交换） 冒泡排序1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); for (int i = len - 1; i &gt;= 0; i--) &#123; // 先默认数组是有序的，只要发生一次交换，就必须进行下一轮比较， // 如果在内层循环中，都没有执行一次交换操作，说明此时数组已经是升序数组 bool sorted = true; // 注意边界，&lt;不是&lt;= for (int j = 0; j &lt; i; j++) &#123; if (nums[j] &gt; nums[j + 1]) &#123; swap(nums[j], nums[j + 1]); sorted = false; &#125; &#125; if (sorted) &#123; break; &#125; &#125; return nums; &#125;&#125;;// 思路：每一轮两两比较，把无序区最大的元素放到了无序区的末尾（有序区的前端）；// 时间复杂度：O(N^2)// 空间复杂度: O(1)// 稳定 归并排序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution &#123;public: vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); // !!!别写成len-1 vector&lt;int&gt; temp(len); mergeSort(nums, 0, len - 1, temp); return nums; &#125; void mergeSort(vector&lt;int&gt;&amp; nums, int left, int right, vector&lt;int&gt;&amp; temp) &#123; // !!!重要，否则死循环 left right是关键字 if (left == right) &#123; return; &#125; int mid = left + (right - left) / 2; mergeSort(nums, left, mid, temp); mergeSort(nums, mid + 1, right, temp); if (nums[mid] &lt;= nums[mid + 1]) &#123; return; &#125; merge(nums, left, mid, right, temp); &#125; void merge(vector&lt;int&gt;&amp; nums, int left, int mid, int right, vector&lt;int&gt;&amp; temp) &#123; // !!!注意copy( InputIt first, InputIt last, OutputIt d_first ); copy(nums.begin() + left, nums.begin() + right + 1, temp.begin() + left); int i = left; int j = mid + 1; for (int k = left; k &lt;= right; k++) &#123; if (i == mid + 1) &#123; nums[k] = temp[j]; j++; &#125; else if (j == right + 1) &#123; nums[k] = temp[i]; i++; &#125; else if (temp[i] &lt;= temp[j]) &#123; // 注意写成 &lt; 就丢失了稳定性（相同元素原来靠前的排序以后依然靠前） nums[k] = temp[i]; i++; &#125; else &#123; nums[k] = temp[j]; j++; &#125; &#125; &#125;&#125;; 快速排序12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) &#123; quickSort(nums, 0, nums.size() - 1); return nums; &#125; void quickSort(vector&lt;int&gt;&amp; nums, int left, int right) &#123; if (left &gt; right) &#123; return; &#125; int pIndex = partition(nums, left, right); quickSort(nums, left, pIndex - 1); quickSort(nums, pIndex + 1, right); &#125; int partition(vector&lt;int&gt;&amp; nums, int left, int right) &#123; int randomIndex = rand() % (right - left + 1) + left; // int randomIndex = (left + right) / 2; swap(nums[left], nums[randomIndex]); int pivot = nums[left]; // lt 是 less than 的缩写，表示（严格）小于 int lt = left; // !! 这里是《= 号 for (int i = left + 1; i &lt;= right; i++) &#123; if (nums[i] &lt; pivot) &#123; lt++; swap(nums[i], nums[lt]); &#125; &#125; // !!注意交换的下标到底是什么 swap(nums[left], nums[lt]); return lt; &#125;&#125;; leetcode排序相关题目列表 题目 题解 知识点 26. 删除排序数组中的重复项（简单） 27. 移除元素（简单） 66. 加一（简单） 88. 合并两个有序数组 从后向前归并 注意这里从后向前归并。 189. 旋转数组 记住这个旋转三次的操作。 451. 根据字符出现频率排序（中等） 和排序相关的经典问题，做法不唯一。 8. 字符串转换整数 (atoi) 尽量不使用库函数、一次遍历（Java） 剑指 Offer 51. 数组中的逆序对难度困难222收藏分享切换为英文关注反馈 在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution &#123;public: int reversePairs(vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); if (len &lt; 2) &#123; return 0; &#125; vector&lt;int&gt; temp(len); return mergeSort(nums, 0, len - 1,temp); &#125; int mergeSort(vector&lt;int&gt;&amp; nums, int left, int right, vector&lt;int&gt;&amp; temp) &#123; if (left == right) &#123; return 0; &#125; int mid = left + (right - left) / 2; int leftPairs = mergeSort(nums, left, mid, temp); int rightPairs = mergeSort(nums, mid + 1, right, temp); if (nums[mid] &lt;= nums[mid + 1] ) &#123; return leftPairs + rightPairs; &#125; int mergerPairs = merge(nums, left, mid, right, temp); return leftPairs + rightPairs + mergerPairs; &#125; int merge(vector&lt;int&gt;&amp; nums, int left, int mid, int right, vector&lt;int&gt;&amp; temp) &#123; // 注意temp也从begin() + left开始 copy(nums.begin() + left, nums.begin() + right + 1, temp.begin() + left); int cnt = 0; int i = left; int j = mid + 1; for (int k = left; k &lt;= right; k++) &#123; if (i == mid + 1) &#123; nums[k] = temp[j]; j++; &#125; else if (j == right + 1) &#123; nums[k] = temp[i]; i++; &#125; else if (temp[i] &lt;= temp[j]) &#123; nums[k] = temp[i]; i++; &#125; else &#123; nums[k] = temp[j]; j++; cnt += (mid - i + 1); &#125; &#125; return cnt; &#125;&#125;; 315. 计算右侧小于当前元素的个数难度困难409收藏分享切换为英文关注反馈 给定一个整数数组 nums，按要求返回一个新数组 counts。数组 counts 有该性质： counts[i] 的值是 nums[i] 右侧小于 nums[i] 的元素的数量。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class Solution &#123;public: vector&lt;int&gt; countSmaller(vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); if (len == 0) &#123; return &#123;&#125;; &#125; vector&lt;int&gt; temp(len); vector&lt;int&gt; index(len); vector&lt;int&gt; res(len); for (int i = 0 ; i &lt; len; i++) &#123; index[i] = i; &#125; mergeSort(nums, 0, len - 1, temp, index, res); return res; &#125; void mergeSort(vector&lt;int&gt;&amp; nums, int left, int right, vector&lt;int&gt;&amp; temp, vector&lt;int&gt;&amp; index, vector&lt;int&gt;&amp; res) &#123; if (left == right) &#123; return; &#125; int mid = left + (right - left) / 2; mergeSort(nums, left, mid, temp, index, res); mergeSort(nums, mid + 1, right, temp, index, res); if (nums[index[mid]] &lt;= nums[index[mid + 1]] ) &#123; return; &#125; merge(nums, left, mid, right, temp, index, res); &#125; void merge(vector&lt;int&gt;&amp; nums, int left, int mid, int right, vector&lt;int&gt;&amp; temp, vector&lt;int&gt;&amp; index, vector&lt;int&gt;&amp; res) &#123; for (int i = left; i &lt;= right; i++) &#123; temp[i] = index[i]; &#125; int i = left; int j = mid + 1; for (int k = left; k &lt;= right; k++) &#123; if (i &gt; mid) &#123; index[k] = temp[j]; j++; &#125; else if (j &gt; right) &#123; index[k] = temp[i]; i++; // right - mid = 右边数组的长度 res[index[k]] += right - mid; &#125; else if (nums[temp[i]] &lt;= nums[temp[j]]) &#123; index[k] = temp[i]; i++; // 1 个子区间元素归并回去的时候 res[index[k]] += j - mid - 1; &#125; else &#123; index[k] = temp[j]; j++; &#125; &#125; &#125;&#125;; 215. 数组中的第K个最大元素难度中等613 在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; int len = nums.size(); int left = 0; int right = len - 1; // top 1 =&gt; len - 1 // top k = &gt; len - k int target = len - k; while (true) &#123; int index = partition(nums, left, right); if (index == target) &#123; return nums[index]; &#125; else if (index &lt; target) &#123; left = index + 1; &#125; else &#123; right = index - 1; &#125; &#125; &#125; // partition并且返回pivot的位置下标 int partition(vector&lt;int&gt;&amp; nums, int left, int right) &#123; int randomIndex = rand() % (right - left + 1) + left; swap(nums[left], nums[randomIndex]); int pivot = nums[left]; int lt = left; for (int i = left + 1; i &lt;= right; i++) &#123; if (nums[i] &lt; pivot) &#123; lt++; swap(nums[i], nums[lt]); &#125; &#125; swap(nums[lt], nums[left]); return lt; &#125;&#125;; 堆123456789101112131415class Solution &#123;public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; int len = nums.size(); int target = len - k; priority_queue&lt;int&gt; q; for (int i = 0; i &lt; len; i++) &#123; q.push(nums[i]); if (i &gt; target) &#123; q.pop(); &#125; &#125; return q.top(); &#125;&#125;; 75. 颜色分类难度中等552收藏分享切换为英文关注反馈 给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。 此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。 12345678910111213141516171819202122232425class Solution &#123;public: void sortColors(vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); int lt = -1; int gt = len; int i = 0; // all in [0, lt] = 0 // all in (zero, i) = 1 // all in [gt, len - 1] = 2 while (i &lt; gt) &#123; if (nums[i] == 0) &#123; lt++; swap(nums[lt], nums[i]); i++; &#125; else if (nums[i] == 1) &#123; i++; &#125; else &#123; gt--; swap(nums[gt], nums[i]); &#125; &#125; return; &#125;&#125;; 堆 小根堆：节点小于左右儿子 存储：一维数组 down up 手写堆 12345678910111213141516// 1. 插入一个数heap[++size] = x;up(size);// 2. 求最小值heap[1]// 3. 删除最小值heap[1] = heap[size];size--;down(1);// 4. 删除任意一个元素heap(k) = heap[size];size--;down(k);up(k);// 只有一个会被执行// 5. 修改任意一个元素heap[k] = x;down(k);up(k);// 只有一个会被执行 [838. 堆排序][https://www.acwing.com/problem/content/840/]1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;stdio.h&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100010;int n, m;int h[N], cnt;void down(int u) &#123; int t = u; if (u * 2 &lt;= cnt &amp;&amp; h[u * 2] &lt; h[t]) &#123; t = u * 2; &#125; if (u * 2 + 1 &lt;= cnt &amp;&amp; h[u * 2 + 1] &lt; h[t]) &#123; t = u * 2 + 1; &#125; if (t != u) &#123; swap(h[u], h[t]); down(t); &#125; &#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); cnt = n; for (int i = 1 ; i &lt;= n; i++) &#123; scanf("%d", &amp;h[i]); &#125; // O(n) 复杂度 for (int i = n / 2; i &gt; 0; i--) &#123; down(i); &#125; while (m -- ) &#123; printf("%d ", h[1]); h[1] = h[cnt--]; down(1); &#125; return 0;&#125; 215. 数组中的第K个最大元素12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; int len = nums.size(); int target = len - k; if (k &lt;= target) &#123; // 小根堆 priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q; for (int i = 0; i &lt; k; i++) &#123; q.push(nums[i]); &#125; for (int i = k; i &lt; len; i++) &#123; if (nums[i] &gt; q.top()) &#123; q.push(nums[i]); q.pop(); &#125; &#125; return q.top(); &#125; else &#123; // 大根堆 priority_queue&lt;int&gt; q; for (int i = 0; i &lt;= target; i++) &#123; q.push(nums[i]); &#125; for (int i = target + 1; i &lt; len; i++) &#123; if (nums[i] &lt; q.top()) &#123; q.push(nums[i]); q.pop(); &#125; &#125; return q.top(); &#125; &#125;&#125;; 347. 前 K 个高频元素1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123; vector&lt;int&gt; res; unordered_map&lt;int, int&gt; freq; using pii = std::pair&lt;int, int&gt;; priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt;&gt; pq; for (int num : nums) &#123; ++freq[num]; &#125; for (pair&lt;int, int&gt; p : freq) &#123; pq.push(pii(p.second, p.first)); if (pq.size() &gt; k) &#123; pq.pop(); &#125; &#125; while (!pq.empty()) &#123; res.emplace_back(pq.top().second); pq.pop(); &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode刷题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode整理]]></title>
    <url>%2F2021%2F04%2F18%2F%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[前言leetcode题目整理 12345678910111213141516* struct TreeNode &#123;* int val;* TreeNode *left;* TreeNode *right;* TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;* TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;* TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;* &#125;; * struct ListNode &#123;* int val;* ListNode *next;* ListNode() : val(0), next(nullptr) &#123;&#125;* ListNode(int x) : val(x), next(nullptr) &#123;&#125;* ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;* &#125;; 题解分类排序 题目 题解 知识点 26. 删除排序数组中的重复项（简单） 27. 移除元素（简单） 66. 加一（简单） 88. 合并两个有序数组 从后向前归并 注意这里从后向前归并。 189. 旋转数组 记住这个旋转三次的操作。 451. 根据字符出现频率排序（中等） 和排序相关的经典问题，做法不唯一。 8. 字符串转换整数 (atoi) 尽量不使用库函数、一次遍历（Java） 问题 自定义排序 选择排序912. 排序数组难度中等182收藏分享切换为英文接收动态反馈 给你一个整数数组 nums，请你将该数组升序排列。 1234567891011121314151617181920class Solution &#123;public: vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); for (int i = 0; i &lt; len; i++) &#123; int minIndex = i; for (int j = i + 1; j &lt; len; j++) &#123; if (nums[j] &lt; nums[minIndex]) &#123; minIndex = j; &#125; &#125; swap(nums[i], nums[minIndex]); &#125; return nums; &#125;&#125;;// 思路：每一轮从无序区中选择最小的元素，放在有序区的后面（即无序区的开头）。比较得多，交换得少// 时间复杂度：O(N^2)// 空间复杂度：O(1)// 不稳定（有交换操作） 插入排序1234567891011121314151617181920class Solution &#123;public: vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); for (int i = 0; i &lt; len; i++) &#123; int j = i; int temp = nums[i]; while (j &gt; 0 &amp;&amp; nums[j - 1] &gt; temp) &#123; nums[j] = nums[j - 1]; // 向后退一格 j--; // 给nums[i]留出可能要插入的位置 &#125; nums[j] = temp; &#125; return nums; &#125;&#125;;// 思路：每一轮把无序区的第一个元素插入到有序区中。比较得少，交换得多。// 时间复杂度：O(n^2)// 空间复杂度：O(1)// 稳定（并没有交换） 冒泡排序1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); for (int i = len - 1; i &gt;= 0; i--) &#123; // 先默认数组是有序的，只要发生一次交换，就必须进行下一轮比较， // 如果在内层循环中，都没有执行一次交换操作，说明此时数组已经是升序数组 bool sorted = true; // 注意边界，&lt;不是&lt;= for (int j = 0; j &lt; i; j++) &#123; if (nums[j] &gt; nums[j + 1]) &#123; swap(nums[j], nums[j + 1]); sorted = false; &#125; &#125; if (sorted) &#123; break; &#125; &#125; return nums; &#125;&#125;;// 思路：每一轮两两比较，把无序区最大的元素放到了无序区的末尾（有序区的前端）；// 时间复杂度：O(N^2)// 空间复杂度: O(1)// 稳定 归并排序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution &#123;public: vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); // !!!别写成len-1 vector&lt;int&gt; temp(len); mergeSort(nums, 0, len - 1, temp); return nums; &#125; void mergeSort(vector&lt;int&gt;&amp; nums, int left, int right, vector&lt;int&gt;&amp; temp) &#123; // !!!重要，否则死循环 left right是关键字 if (left == right) &#123; return; &#125; int mid = left + (right - left) / 2; mergeSort(nums, left, mid, temp); mergeSort(nums, mid + 1, right, temp); if (nums[mid] &lt;= nums[mid + 1]) &#123; return; &#125; merge(nums, left, mid, right, temp); &#125; void merge(vector&lt;int&gt;&amp; nums, int left, int mid, int right, vector&lt;int&gt;&amp; temp) &#123; // !!!注意copy( InputIt first, InputIt last, OutputIt d_first ); copy(nums.begin() + left, nums.begin() + right + 1, temp.begin() + left); int i = left; int j = mid + 1; for (int k = left; k &lt;= right; k++) &#123; if (i == mid + 1) &#123; nums[k] = temp[j]; j++; &#125; else if (j == right + 1) &#123; nums[k] = temp[i]; i++; &#125; else if (temp[i] &lt;= temp[j]) &#123; // 注意写成 &lt; 就丢失了稳定性（相同元素原来靠前的排序以后依然靠前） nums[k] = temp[i]; i++; &#125; else &#123; nums[k] = temp[j]; j++; &#125; &#125; &#125;&#125;; 剑指 Offer 51. 数组中的逆序对难度困难222收藏分享切换为英文关注反馈 在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution &#123;public: int reversePairs(vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); if (len &lt; 2) &#123; return 0; &#125; vector&lt;int&gt; temp(len); return mergeSort(nums, 0, len - 1,temp); &#125; int mergeSort(vector&lt;int&gt;&amp; nums, int left, int right, vector&lt;int&gt;&amp; temp) &#123; if (left == right) &#123; return 0; &#125; int mid = left + (right - left) / 2; int leftPairs = mergeSort(nums, left, mid, temp); int rightPairs = mergeSort(nums, mid + 1, right, temp); if (nums[mid] &lt;= nums[mid + 1] ) &#123; return leftPairs + rightPairs; &#125; int mergerPairs = merge(nums, left, mid, right, temp); return leftPairs + rightPairs + mergerPairs; &#125; int merge(vector&lt;int&gt;&amp; nums, int left, int mid, int right, vector&lt;int&gt;&amp; temp) &#123; // 注意temp也从begin() + left开始 copy(nums.begin() + left, nums.begin() + right + 1, temp.begin() + left); int cnt = 0; int i = left; int j = mid + 1; for (int k = left; k &lt;= right; k++) &#123; if (i == mid + 1) &#123; nums[k] = temp[j]; j++; &#125; else if (j == right + 1) &#123; nums[k] = temp[i]; i++; &#125; else if (temp[i] &lt;= temp[j]) &#123; nums[k] = temp[i]; i++; &#125; else &#123; nums[k] = temp[j]; j++; cnt += (mid - i + 1); &#125; &#125; return cnt; &#125;&#125;; 315. 计算右侧小于当前元素的个数难度困难409收藏分享切换为英文关注反馈 给定一个整数数组 nums，按要求返回一个新数组 counts。数组 counts 有该性质： counts[i] 的值是 nums[i] 右侧小于 nums[i] 的元素的数量。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class Solution &#123;public: vector&lt;int&gt; countSmaller(vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); if (len == 0) &#123; return &#123;&#125;; &#125; vector&lt;int&gt; temp(len); vector&lt;int&gt; index(len); vector&lt;int&gt; res(len); for (int i = 0 ; i &lt; len; i++) &#123; index[i] = i; &#125; mergeSort(nums, 0, len - 1, temp, index, res); return res; &#125; void mergeSort(vector&lt;int&gt;&amp; nums, int left, int right, vector&lt;int&gt;&amp; temp, vector&lt;int&gt;&amp; index, vector&lt;int&gt;&amp; res) &#123; if (left == right) &#123; return; &#125; int mid = left + (right - left) / 2; mergeSort(nums, left, mid, temp, index, res); mergeSort(nums, mid + 1, right, temp, index, res); if (nums[index[mid]] &lt;= nums[index[mid + 1]] ) &#123; return; &#125; merge(nums, left, mid, right, temp, index, res); &#125; void merge(vector&lt;int&gt;&amp; nums, int left, int mid, int right, vector&lt;int&gt;&amp; temp, vector&lt;int&gt;&amp; index, vector&lt;int&gt;&amp; res) &#123; for (int i = left; i &lt;= right; i++) &#123; temp[i] = index[i]; &#125; int i = left; int j = mid + 1; for (int k = left; k &lt;= right; k++) &#123; if (i &gt; mid) &#123; index[k] = temp[j]; j++; &#125; else if (j &gt; right) &#123; index[k] = temp[i]; i++; // right - mid = 右边数组的长度 res[index[k]] += right - mid; &#125; else if (nums[temp[i]] &lt;= nums[temp[j]]) &#123; index[k] = temp[i]; i++; // 1 个子区间元素归并回去的时候 res[index[k]] += j - mid - 1; &#125; else &#123; index[k] = temp[j]; j++; &#125; &#125; &#125;&#125;; 快速排序12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) &#123; quickSort(nums, 0, nums.size() - 1); return nums; &#125; void quickSort(vector&lt;int&gt;&amp; nums, int left, int right) &#123; if (left &gt; right) &#123; return; &#125; int pIndex = partition(nums, left, right); quickSort(nums, left, pIndex - 1); quickSort(nums, pIndex + 1, right); &#125; int partition(vector&lt;int&gt;&amp; nums, int left, int right) &#123; int randomIndex = rand() % (right - left + 1) + left; // int randomIndex = (left + right) / 2; swap(nums[left], nums[randomIndex]); int pivot = nums[left]; // lt 是 less than 的缩写，表示（严格）小于 int lt = left; // !! 这里是《= 号 for (int i = left + 1; i &lt;= right; i++) &#123; if (nums[i] &lt; pivot) &#123; lt++; swap(nums[i], nums[lt]); &#125; &#125; // !!注意交换的下标到底是什么 swap(nums[left], nums[lt]); return lt; &#125;&#125;; 215. 数组中的第K个最大元素难度中等613 在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; int len = nums.size(); int left = 0; int right = len - 1; // top 1 =&gt; len - 1 // top k = &gt; len - k int target = len - k; while (true) &#123; int index = partition(nums, left, right); if (index == target) &#123; return nums[index]; &#125; else if (index &lt; target) &#123; left = index + 1; &#125; else &#123; right = index - 1; &#125; &#125; &#125; // partition并且返回pivot的位置下标 int partition(vector&lt;int&gt;&amp; nums, int left, int right) &#123; int randomIndex = rand() % (right - left + 1) + left; swap(nums[left], nums[randomIndex]); int pivot = nums[left]; int lt = left; for (int i = left + 1; i &lt;= right; i++) &#123; if (nums[i] &lt; pivot) &#123; lt++; swap(nums[i], nums[lt]); &#125; &#125; swap(nums[lt], nums[left]); return lt; &#125;&#125;; 堆123456789101112131415class Solution &#123;public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; int len = nums.size(); int target = len - k; priority_queue&lt;int&gt; q; for (int i = 0; i &lt; len; i++) &#123; q.push(nums[i]); if (i &gt; target) &#123; q.pop(); &#125; &#125; return q.top(); &#125;&#125;; 75. 颜色分类难度中等552收藏分享切换为英文关注反馈 给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。 此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。 12345678910111213141516171819202122232425class Solution &#123;public: void sortColors(vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); int lt = -1; int gt = len; int i = 0; // all in [0, lt] = 0 // all in (zero, i) = 1 // all in [gt, len - 1] = 2 while (i &lt; gt) &#123; if (nums[i] == 0) &#123; lt++; swap(nums[lt], nums[i]); i++; &#125; else if (nums[i] == 1) &#123; i++; &#125; else &#123; gt--; swap(nums[gt], nums[i]); &#125; &#125; return; &#125;&#125;; 堆 小根堆：节点小于左右儿子 存储：一维数组 down up 手写堆 12345678910111213141516// 1. 插入一个数heap[++size] = x;up(size);// 2. 求最小值heap[1]// 3. 删除最小值heap[1] = heap[size];size--;down(1);// 4. 删除任意一个元素heap(k) = heap[size];size--;down(k);up(k);// 只有一个会被执行// 5. 修改任意一个元素heap[k] = x;down(k);up(k);// 只有一个会被执行 [838. 堆排序][https://www.acwing.com/problem/content/840/]1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;stdio.h&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100010;int n, m;int h[N], cnt;void down(int u) &#123; int t = u; if (u * 2 &lt;= cnt &amp;&amp; h[u * 2] &lt; h[t]) &#123; t = u * 2; &#125; if (u * 2 + 1 &lt;= cnt &amp;&amp; h[u * 2 + 1] &lt; h[t]) &#123; t = u * 2 + 1; &#125; if (t != u) &#123; swap(h[u], h[t]); down(t); &#125; &#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); cnt = n; for (int i = 1 ; i &lt;= n; i++) &#123; scanf("%d", &amp;h[i]); &#125; // O(n) 复杂度 for (int i = n / 2; i &gt; 0; i--) &#123; down(i); &#125; while (m -- ) &#123; printf("%d ", h[1]); h[1] = h[cnt--]; down(1); &#125; return 0;&#125; 215. 数组中的第K个最大元素12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; int len = nums.size(); int target = len - k; if (k &lt;= target) &#123; // 小根堆 priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q; for (int i = 0; i &lt; k; i++) &#123; q.push(nums[i]); &#125; for (int i = k; i &lt; len; i++) &#123; if (nums[i] &gt; q.top()) &#123; q.push(nums[i]); q.pop(); &#125; &#125; return q.top(); &#125; else &#123; // 大根堆 priority_queue&lt;int&gt; q; for (int i = 0; i &lt;= target; i++) &#123; q.push(nums[i]); &#125; for (int i = target + 1; i &lt; len; i++) &#123; if (nums[i] &lt; q.top()) &#123; q.push(nums[i]); q.pop(); &#125; &#125; return q.top(); &#125; &#125;&#125;; 347. 前 K 个高频元素1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123; vector&lt;int&gt; res; unordered_map&lt;int, int&gt; freq; using pii = std::pair&lt;int, int&gt;; priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt;&gt; pq; for (int num : nums) &#123; ++freq[num]; &#125; for (pair&lt;int, int&gt; p : freq) &#123; pq.push(pii(p.second, p.first)); if (pq.size() &gt; k) &#123; pq.pop(); &#125; &#125; while (!pq.empty()) &#123; res.emplace_back(pq.top().second); pq.pop(); &#125; return res; &#125;&#125;; 二分 题目 知识点 5489. 两球之间的磁力 最小化最大值 410. 分割数组的最大值 同上 875. 爱吃香蕉的珂珂 同上 704. 二分查找难度简单225收藏分享切换为英文接收动态反馈 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。 1234567891011121314151617181920class Solution &#123;public: int search(vector&lt;int&gt;&amp; nums, int target) &#123; int l = 0; int r = nums.size() - 1; while (l &lt; r) &#123; int mid = (l + r) / 2; if (nums[mid] &lt; target) &#123; l = mid + 1; &#125; else &#123; r = mid; &#125; &#125; if (nums[l] == target) &#123; return l; &#125; else &#123; return -1; &#125; &#125;&#125;; 小结 二分最基础问题 5489. 两球之间的磁力难度中等3收藏分享切换为英文关注反馈 在代号为 C-137 的地球上，Rick 发现如果他将两个球放在他新发明的篮子里，它们之间会形成特殊形式的磁力。Rick 有 n 个空的篮子，第 i 个篮子的位置在 position[i] ，Morty 想把 m 个球放到这些篮子里，使得任意两球间 最小磁力 最大。 已知两个球如果分别位于 x 和 y ，那么它们之间的磁力为 |x - y| 。 给你一个整数数组 position 和一个整数 m ，请你返回最大化的最小磁力。 1234567891011121314151617181920212223242526272829303132333435363738const int INF = 1e9 + 5;class Solution &#123;public: int maxDistance(vector&lt;int&gt;&amp; position, int m) &#123; int left = 0; int right = INF; int ans = 0; int len = position.size(); // 要二分，先排序 sort(position.begin(), position.end()); while (left &lt; right) &#123; int mid = (left + right + 1) / 2; if (check(mid, position, m, len)) &#123; left = mid; &#125; else &#123; right = mid - 1; &#125; &#125; return left; &#125; bool check(int d, vector&lt;int&gt;&amp; p, int m, int n) &#123; // 贪心地在第一个位置放一个球 int last = p[0]; m--; for (int i = 1; i &lt; n &amp;&amp; m &gt; 0; i++) &#123; if (p[i] - last &gt;= d) &#123; --m; // 距离满足条件，贪心地放一个球 last = p[i]; &#125; &#125; return m &lt;= 0; &#125;&#125;; 知识点 最大化最小，最小化最大，想到二分 int INF 1234567891011121314151617181920212223242526272829303132333435363738394041#### [410. 分割数组的最大值](https://leetcode-cn.com/problems/split-array-largest-sum/)难度困难305收藏分享切换为英文关注反馈给定一个非负整数数组和一个整数 *m*，你需要将这个数组分成 *m* 个非空的连续子数组。设计一个算法使得这 *m* 个子数组各自和的最大值最小。##### DP```c++class Solution &#123;public: int splitArray(vector&lt;int&gt;&amp; nums, int m) &#123; int n = nums.size(); // 假设f[i][j]表示前i个数分成j段的最小最大和 vector&lt;vector&lt;long long&gt;&gt; f(n + 1, vector&lt;long long&gt;(m + 1, LLONG_MAX)); // 前缀和加速计算，sub[i]表示前i个元素之和 // sub[1] = nums[1] // sub[3] = nums[1] + nums[2] + nums[3] // sub[3] - sub[1] = nums[2] + nums[3] // sub[i] - sub[j] vector&lt;long long&gt; sub(n + 1, 0); for (int i = 0; i &lt; n; i++) &#123; sub[i + 1] = sub[i] + nums[i]; &#125; f[0][0] = 0; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= min(i, m); j++) &#123; for (int k = 0; k &lt; i; k++) &#123; // max(f[k][j - 1], sub[i] - sub[k])求得是当前划分的方法下，子数组各自和的最大值的最小值 // nums[k]属于后面 f[i][j] = min(f[i][j], max(f[k][j - 1], sub[i] - sub[k])); &#125; &#125; &#125; return (int)f[n][m]; &#125;&#125;; 知识点 LLONG_MAX. INT_MAX 二分1234567891011121314151617181920212223242526272829303132class Solution &#123;public: int splitArray(vector&lt;int&gt;&amp; nums, int m) &#123; long long left = 0; long long right = INT_MAX; while (left &lt; right) &#123; long long mid = (left + right) / 2; if (check(mid, m, nums)) &#123; right = mid; &#125; else &#123; left = mid + 1; &#125; &#125; return left; &#125; bool check(long long n, int m, vector&lt;int&gt;&amp; nums) &#123; int sum = 0; for (int i = 0; i &lt; nums.size(); i++) &#123; if (nums[i] &gt; n) &#123; return false; &#125; sum += nums[i]; if (sum &gt; n) &#123; sum = nums[i]; m--; &#125; &#125; return m &gt; 0; &#125;&#125;; 875. 爱吃香蕉的珂珂难度中等88收藏分享切换为英文关注反馈 珂珂喜欢吃香蕉。这里有 N 堆香蕉，第 i 堆中有 piles[i] 根香蕉。警卫已经离开了，将在 H 小时后回来。 珂珂可以决定她吃香蕉的速度 K （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 K 根。如果这堆香蕉少于 K 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。 珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。 返回她可以在 H 小时内吃掉所有香蕉的最小速度 K（K 为整数）。 123456789101112131415161718192021222324252627class Solution &#123;public: int minEatingSpeed(vector&lt;int&gt;&amp; piles, int H) &#123; long left = 1; long right = INT_MAX; while (left &lt; right) &#123; long mid = (left + right) / 2; if (check(mid, H, piles)) &#123; right = mid; &#125; else &#123; left = mid + 1; &#125; cout &lt;&lt;left &lt;&lt; &quot; &quot; &lt;&lt; right &lt;&lt; endl; &#125; return left; &#125; bool check(long n, int h, vector&lt;int&gt;&amp; piles) &#123; int cnt = 0; for (int p : piles) &#123; // 边界条件要注意 cnt += (p - 1) / n + 1; &#125; return cnt &lt;= h; &#125;&#125;; 记忆化搜索5490. 吃掉 N 个橘子的最少天数难度困难10收藏分享切换为英文关注反馈 厨房里总共有 n 个橘子，你决定每一天选择如下方式之一吃这些橘子： 吃掉一个橘子。 如果剩余橘子数 n 能被 2 整除，那么你可以吃掉 n/2 个橘子。 如果剩余橘子数 n 能被 3 整除，那么你可以吃掉 2*(n/3) 个橘子。 每天你只能从以上 3 种方案中选择一种方案。 请你返回吃掉所有 n 个橘子的最少天数。 123456789101112131415161718192021class Solution &#123;public: unordered_map&lt;int, int&gt; dp; int minDays(int n) &#123; // n = 0 n = 1作为递归出口就够了 if (n &lt;= 1) &#123; return n; &#125; // 特别注意，不要单独考虑吃掉一个橘子的情况 // 一方面，可以吃点1/2,或者2/3的橘子总是更好的 // 另一方面，考虑只吃一个的话，就会有n个状态，会超时 if (dp.count(n)) &#123; return dp[n]; &#125; int res = min(minDays(n / 2) + 1 + n % 2, minDays(n / 3) + 1 + n % 3); dp[n] = res; return res; &#125;&#125;; DFS733. 图像渲染难度简单108收藏分享切换为英文关注反馈 有一幅以二维整数数组表示的图画，每一个整数表示该图画的像素值大小，数值在 0 到 65535 之间。 给你一个坐标 (sr, sc) 表示图像渲染开始的像素值（行 ，列）和一个新的颜色值 newColor，让你重新上色这幅图像。 123456789101112131415161718192021222324252627class Solution &#123;public: vector&lt;int&gt; dx = &#123;1, 0, -1, 0&#125;; vector&lt;int&gt; dy = &#123;0, 1, 0, -1&#125;; vector&lt;vector&lt;int&gt;&gt; floodFill(vector&lt;vector&lt;int&gt;&gt;&amp; image, int sr, int sc, int newColor) &#123; int initcolor = image[sr][sc]; if (initcolor == newColor) &#123; return image; &#125; dfs(image, sr, sc, newColor, initcolor); return image; &#125; void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; image, int r, int c, int newColor, int initcolor) &#123; if (r &lt; 0 || r &gt;= image.size() || c &lt; 0 || c &gt;= image[0].size() || image[r][c] != initcolor) &#123; return; &#125; // 染色，防止重复 image[r][c] = newColor; for (int i = 0 ; i &lt; 4; i++) &#123; int new_x = r + dx[i]; int new_y = c + dy[i]; dfs(image, new_x, new_y, newColor, initcolor); &#125; &#125; 123456789101112131415161718192021222324252627282930class Solution &#123;public: vector&lt;int&gt; dx = &#123;1, 0, -1, 0&#125;; vector&lt;int&gt; dy = &#123;0, 1, 0, -1&#125;; vector&lt;vector&lt;int&gt;&gt; floodFill(vector&lt;vector&lt;int&gt;&gt;&amp; image, int sr, int sc, int newColor) &#123; int initcolor = image[sr][sc]; // 特判，无需染色 if (initcolor == newColor) &#123; return image; &#125; queue&lt;pair&lt;int, int&gt;&gt; q; q.push(&#123;sr, sc&#125;); while (!q.empty()) &#123; pair&lt;int, int&gt; point = q.front(); q.pop(); image[point.first][point.second] = newColor; for (int i = 0; i &lt; 4; i++) &#123; int x = point.first + dx[i]; int y = point.second + dy[i]; if (0 &lt;= x &amp;&amp; x &lt; image.size() &amp;&amp; 0 &lt;= y &amp;&amp; y &lt; image[0].size() &amp;&amp; image[x][y] == initcolor) &#123; q.push(&#123;x, y&#125;); &#125; &#125; &#125; return image; &#125;&#125;; 回溯算法题型 1：基本回溯问题，在数组上进行搜索 题目序号 题解 知识点 代码 46. 全排列（中等） 从全排列问题开始理解“回溯搜索”算法 47. 全排列 II（中等） 回溯搜索 + 剪枝 理解深度优先遍历，发现剪枝条件。 39. 组合总和 回溯算法 + 剪枝 画树形图。 40. 组合总和 II 回溯算法 + 剪枝 画树形图。 78. 子集 回溯 + 位掩码 经典问题。 90. 子集 II 经典问题。 77. 组合 回溯算法 + 剪枝 题目：113. 路径总和 II 回溯算法（深度优先遍历 + 状态重置） 题型 2：字符串上的回溯问题 重点理解：由于字符串每次都生成新字符，无须状态重置。 题目序号 题解 知识点 代码 17 .电话号码的字母组合 回溯搜索（无显式回溯）、广度优先遍历 字符串的回溯问题。 22. 括号生成 回溯算法（深度优先遍历）+ 广度优先遍历 字符串的回溯问题。 93. 复原IP地址 回溯算法（画图分析剪枝条件） 字符串的回溯问题。 784. 字母大小写全排列 在隐式树上做深度优先遍历 字符串的回溯问题。 题型 3：二维平面上的回溯问题 题目序号 题解 知识点 代码 79. 单词搜索（中等） 在二维平面上使用回溯法 题型 4：一些游戏问题 题目序号 题解 知识点 代码 51. N皇后 根据第 46 题“全排列”的“回溯算法”思路编写“N 皇后”问题 经典问题，掌握「空间换时间」技巧。 37. 解数独（困难） 36. 有效的数独（中等） 这里用到的是哈希表。 题型 5：巧用剪枝 题目序号 题解 知识点 代码 60. 第k个排列 深度优先遍历 + 剪枝、双链表模拟 可以基于第 46 题做，剪枝直接来到枝叶。 46. 全排列难度中等881收藏分享切换为英文关注反馈 给定一个 没有重复 数字的序列，返回其所有可能的全排列。 123456789101112131415161718192021222324252627class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; path; vector&lt;int&gt; visited(nums.size()); dfs(nums, 0, path, res, visited); return res; &#125; void dfs(vector&lt;int&gt;&amp; nums, int pos, vector&lt;int&gt;&amp; path, vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; visited) &#123; if (pos == nums.size()) &#123; res.push_back(path); return; &#125; for (int i = 0; i &lt; nums.size(); i++) &#123; if (visited[i] == 0) &#123; path.push_back(nums[i]); visited[i] = 1; dfs(nums, pos + 1, path, res, visited); visited[i] = 0; path.pop_back(); &#125; &#125; &#125;&#125;; 47. 全排列 II难度中等396 给定一个可包含重复数字的序列，返回所有不重复的全排列。 12345678910111213141516171819202122232425262728class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; path; vector&lt;int&gt; visited(nums.size()); dfs(0, nums, path, visited, res); return res; &#125; void dfs(int depth, vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; path, vector&lt;int&gt;&amp; visited, vector&lt;vector&lt;int&gt;&gt;&amp; res) &#123; if (depth == nums.size()) &#123; res.push_back(path); return; &#125; for (int i = 0; i &lt; nums.size(); i++) &#123; if (visited[i] == 0 &amp;&amp; (i == 0 || nums[i] != nums[i - 1] || visited[i - 1] == 1)) &#123; path.push_back(nums[i]); visited[i] = 1; dfs(depth + 1, nums, path, visited, res); visited[i] = 0; path.pop_back(); &#125; &#125; &#125;&#125;; 知识点 visited数组直接声明而未初始化和nums数组一样的长度，导致其被访问的时候出错 78. 子集难度中等747收藏分享切换为英文关注反馈 给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 123456789101112131415161718192021class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; path; vector&lt;vector&lt;int&gt;&gt; res; dfs(0, nums, path, res); return res; &#125; void dfs(int pos, vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; path, vector&lt;vector&lt;int&gt;&gt;&amp; res) &#123; if (pos == nums.size()) &#123; res.push_back(path); return; &#125; path.push_back(nums[pos]); dfs(pos + 1, nums, path, res); path.pop_back(); dfs(pos + 1, nums, path, res); &#125;&#125;; 90. 子集 II难度中等302收藏分享切换为英文关注反馈 给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 说明：解集不能包含重复的子集。 123456789101112131415161718192021222324252627282930class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; path; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; visited(nums.size()); sort(nums.begin(), nums.end()); dfs(0, nums, path, res, visited); return res; &#125; void dfs(int pos, vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; path, vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; visited) &#123; if (pos == nums.size()) &#123; res.push_back(path); return; &#125; if (pos == 0 || nums[pos] != nums[pos - 1] || visited[pos - 1] == 1) &#123; path.push_back(nums[pos]); visited[pos] = 1; dfs(pos + 1, nums, path, res, visited); visited[pos] = 0; path.pop_back(); &#125; dfs(pos + 1, nums, path, res, visited); &#125;&#125;; 77. 组合难度中等387收藏分享切换为英文关注反馈 给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。 123456789101112131415161718192021222324class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123; vector&lt;int&gt; path; vector&lt;vector&lt;int&gt;&gt; res; dfs(n, k, 1, path, res); return res; &#125; void dfs(int n, int k, int num, vector&lt;int&gt;&amp; path, vector&lt;vector&lt;int&gt;&gt;&amp; res) &#123; if (path.size() == k) &#123; res.push_back(path); return; &#125; else if (num == n + 1) &#123; return; &#125; path.push_back(num); dfs(n, k, num + 1, path, res); path.pop_back(); dfs(n, k, num + 1, path, res); &#125;&#125;; 40. 组合总和 II难度中等395收藏分享切换为英文关注反馈 给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的每个数字在每个组合中只能使用一次。 解法1123456789101112131415161718192021222324252627282930313233class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123; vector&lt;int&gt; path; vector&lt;vector&lt;int&gt;&gt; res; sort(candidates.begin(), candidates.end()); vector&lt;int&gt; visited(candidates.size()); dfs(target, 0, candidates, path, res, visited); return res; &#125; void dfs(int target, int i, vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; path, vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; visited) &#123; if (target == 0) &#123; res.push_back(path); return; &#125; if (target &lt; 0 || i == nums.size()) &#123; return; &#125; if (i == 0 || nums[i] != nums[i - 1] || visited[i - 1] == 1) &#123; path.push_back(nums[i]); visited[i] = 1; dfs(target - nums[i], i + 1, nums, path, res, visited); visited[i] = 0; path.pop_back(); &#125; dfs(target, i + 1, nums, path, res, visited); &#125;&#125;; 解法2123456789101112131415161718192021222324252627282930class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123; vector&lt;int&gt; path; vector&lt;vector&lt;int&gt;&gt; res; sort(candidates.begin(), candidates.end()); dfs(0, target, candidates, path, res); return res; &#125; void dfs(int begin, int target, vector&lt;int&gt;&amp; candidates, vector&lt;int&gt;&amp; path, vector&lt;vector&lt;int&gt;&gt;&amp; res) &#123; if (target == 0) &#123; res.push_back(path); return; &#125; if (target &lt; 0) &#123; return; &#125; for (int i = begin; i &lt; candidates.size(); i++) &#123; if (i == begin || candidates[i] != candidates[i - 1]) &#123; path.push_back(candidates[i]); dfs(i + 1, target - candidates[i], candidates, path, res); path.pop_back(); &#125; &#125; &#125;&#125;; 39. 组合总和难度中等929 给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的数字可以无限制重复被选取。 123456789101112131415161718192021222324class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; path; dfs(candidates, 0, target, path, res); return res; &#125; void dfs(vector&lt;int&gt;&amp; candidates, int begin, int target, vector&lt;int&gt;&amp; path, vector&lt;vector&lt;int&gt;&gt;&amp; res) &#123; if (target == 0) &#123; res.push_back(path); return; &#125; for (int i = begin; i &lt; candidates.size(); i++) &#123; path.push_back(candidates[i]); dfs(candidates, i, target - candidates[i], path, res); path.pop_back(); &#125; &#125;&#125;; 113. 路径总和 II难度中等313 给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。 说明: 叶子节点是指没有子节点的节点。 1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int sum) &#123; vector&lt;int&gt; path; vector&lt;vector&lt;int&gt;&gt; res; dfs(sum, root, path, res); return res; &#125; void dfs(int target, TreeNode* node, vector&lt;int&gt;&amp; path, vector&lt;vector&lt;int&gt;&gt;&amp; res) &#123; if (node == nullptr) &#123; return; &#125; target -= node-&gt;val; path.push_back(node-&gt;val); if (target == 0 &amp;&amp; node-&gt;left == nullptr &amp;&amp; node-&gt;right == nullptr) &#123; res.push_back(path); path.pop_back(); return; &#125; dfs(target, node-&gt;left, path, res); dfs(target, node-&gt;right, path, res); path.pop_back(); &#125;&#125;; 17. 电话号码的字母组合难度中等911收藏分享切换为英文关注反馈 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 12345678910111213141516171819202122232425262728293031class Solution &#123;public: vector&lt;string&gt; letterCombinations(string digits) &#123; if (digits.empty()) &#123; return &#123;&#125;; &#125; unordered_map&lt;char, string&gt; umap &#123; &#123;'2', "abc"&#125;, &#123;'3', "def"&#125;, &#123;'4', "ghi"&#125;, &#123;'5', "jkl"&#125;, &#123;'6', "mno"&#125;, &#123;'7', "pqrs"&#125;, &#123;'8', "tuv"&#125;, &#123;'9', "wxyz"&#125; &#125;; vector&lt;string&gt; res; string str; string path; dfs(0, path, res, digits, umap); return res; &#125; void dfs(int pos, string&amp; path, vector&lt;string&gt;&amp; res, string&amp; digits, unordered_map&lt;char, string&gt;&amp; umap) &#123; if (pos == digits.size()) &#123; res.push_back(path); return; &#125; for (char c : umap[digits[pos]]) &#123; path.push_back(c); dfs(pos + 1, path, res, digits, umap); path.pop_back(); &#125; &#125;&#125;; 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: vector&lt;string&gt; generateParenthesis(int n) &#123; if (n == 0) &#123; return &#123;&#125;; &#125; vector&lt;string&gt; res; dfs("", 0, 0, res, n); return res; &#125; void dfs(string path, int left, int right, vector&lt;string&gt;&amp; res, int n) &#123; // &amp;&amp; left == n不能少，否则出现下面的错误情况 // "(()))" if (right == n &amp;&amp; left == n) &#123; res.push_back(path); return; &#125; if (left &lt; right) &#123; return; &#125; // if (left &lt; n) &#123; dfs(path + '(', left + 1, right, res, n); &#125; dfs(path + ')', left, right + 1, res, n); &#125;&#125;; 双指针15. 三数之和难度中等2639收藏分享切换为英文接收动态反馈 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; // 为了保证不重复 sort(nums.begin(), nums.end()); vector&lt;vector&lt;int&gt;&gt; res; for (int first = 0; first &lt; nums.size(); first++) &#123; // 为了保证不重复 if (first &gt; 0 &amp;&amp; nums[first] == nums[first - 1]) &#123; continue; &#125; int target = -nums[first]; int third = nums.size() - 1; for (int second = first + 1; second &lt; nums.size(); second++) &#123; // 为了保证不重复 if (second &gt; first + 1 &amp;&amp; nums[second] == nums[second - 1]) &#123; continue; &#125; while (second &lt; third &amp;&amp; nums[second] + nums[third] &gt; target) &#123; third--; &#125; if (second == third) &#123; break; &#125; if (nums[second] + nums[third] == target) &#123; res.push_back(&#123;nums[first], nums[second], nums[third]&#125;); &#125; &#125; &#125; return res; &#125;&#125;; 知识点 不重复要想到排序 二叉树必备知识点 二叉树的遍历 知识点 剑指 Offer 07 重建二叉树 中等 区间分治 剑指 Offer 26 树的子结构 中等 剑指 Offer 27 二叉树的镜像 简单 剑指 Offer 28 对称的二叉树 简单 剑指 Offer 37 序列化二叉树 困难 剑指 Offer 32 - I 从上到下打印二叉树 中等 BFS 剑指 Offer 32 - II 从上到下打印二叉树 II 简单 分层BFS 剑指 Offer 32 - III 从上到下打印二叉树 III 中等 剑指 Offer 34 二叉树中和为某一值的路径 中等 回溯 剑指 Offer 55 - I 二叉树的深度 简单 剑指 Offer 54 二叉搜索树的第k大节点 简单 剑指 Offer 55 - II 平衡二叉树 简单 剑指 Offer 68 - I 二叉搜索树的最近公共祖先 简单 剑指 Offer 68 - II 二叉树的最近公共祖先 简单 144. 二叉树的前序遍历难度中等322 给定一个二叉树，返回它的 前序 遍历。 递归1234567891011121314151617class Solution &#123;public: vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; dfs(root, res); return res; &#125; void dfs(TreeNode* root, vector&lt;int&gt;&amp; res) &#123; if (root == nullptr) &#123; return; &#125; res.push_back(root-&gt;val); dfs(root-&gt;left, res); dfs(root-&gt;right, res); &#125;&#125;; 迭代1234567891011121314151617181920212223242526272829class Solution &#123;public: vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; stack&lt;TreeNode*&gt; call; if (root != nullptr) &#123; call.push(root); &#125; while (!call.empty()) &#123; TreeNode* t = call.top(); call.pop(); if (t != nullptr) &#123; if (t-&gt;right) &#123; call.push(t-&gt;right); &#125; if (t-&gt;left) &#123; call.push(t-&gt;left); &#125; call.push(t); call.push(nullptr); &#125; else &#123; res.push_back(call.top()-&gt;val); call.pop(); &#125; &#125; return res; &#125;&#125;; 94. 二叉树的中序遍历难度中等595 给定一个二叉树，返回它的中序 遍历。 12345678910111213141516171819202122232425262728293031class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; stack&lt;TreeNode*&gt; call; if (root != nullptr) &#123; call.push(root); &#125; while (!call.empty()) &#123; TreeNode* t = call.top(); call.pop(); if (t != nullptr) &#123; if (t-&gt;right) &#123; call.push(t-&gt;right); &#125; call.push(t); call.push(nullptr); if (t-&gt;left) &#123; call.push(t-&gt;left); &#125; &#125; else &#123; res.push_back(call.top()-&gt;val); call.pop(); &#125; &#125; return res; &#125;&#125;; 145. 二叉树的后序遍历难度困难353 给定一个二叉树，返回它的 后序 遍历。 123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; stack&lt;TreeNode*&gt; call; if (root != nullptr) &#123; call.push(root); &#125; while (!call.empty()) &#123; TreeNode* cur = call.top(); call.pop(); if (cur != nullptr) &#123; call.push(cur); call.push(nullptr); if (cur-&gt;right) &#123; call.push(cur-&gt;right); &#125; if (cur-&gt;left) &#123; call.push(cur-&gt;left); &#125; &#125; else &#123; res.push_back(call.top()-&gt;val); call.pop(); &#125; &#125; return res; &#125;&#125;; 剑指 Offer 07. 重建二叉树难度中等218收藏分享切换为英文接收动态反馈 输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字 12345678910111213141516171819202122232425262728293031class Solution &#123;public: // 区间分治的题目，使用左闭右闭区间更加方便 // c/c++ 不支持切片语法, 一个数组，使用 3 个变量描述： // 数组本身 arr // 数组的起始位置 lo // 数组的结束位置 hi TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123; // 建一个哈希表，找到根结点在inorder中的下标 unordered_map&lt;int, int&gt; umap; for (int i = 0; i &lt; inorder.size(); i++) &#123; umap[inorder[i]] = i; &#125; return helper(preorder, 0, preorder.size() - 1, inorder, 0, inorder.size() - 1, umap); &#125; TreeNode* helper(vector&lt;int&gt;&amp; preorder, int lo1, int hi1, vector&lt;int&gt;&amp; inorder, int lo2, int hi2, unordered_map&lt;int, int&gt;&amp; umap) &#123; if (lo1 &gt; hi1 || lo2 &gt; hi2) &#123; return nullptr; &#125; int mid = umap[preorder[lo1]]; TreeNode* head = new TreeNode(preorder[lo1]); // 长度 // inorder: [mid - lo2, mid, hi2 - mid] // preorder: [root, mid - lo2, hi2 - mid] head-&gt;left = helper(preorder, lo1 + 1, lo1 + mid - lo2, inorder, lo2, mid - 1, umap); head-&gt;right = helper(preorder, lo1 + mid - lo2 + 1, hi1, inorder, mid + 1, hi2, umap); return head; &#125;&#125;; 剑指 Offer 26. 树的子结构难度中等125收藏分享切换为英文接收动态反馈 输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构) B是A的子结构， 即 A中有出现和B相同的结构和节点值。 12345678910111213141516171819202122class Solution &#123;public: bool isSubStructure(TreeNode* A, TreeNode* B) &#123; if (B == nullptr) &#123; return false; &#125; if (A == nullptr) &#123; return false; &#125; return isSame(A, B) || isSubStructure(A-&gt;left, B) || isSubStructure(A-&gt;right, B); &#125; bool isSame(TreeNode* A, TreeNode* B) &#123; if (B == nullptr) &#123; return true; &#125; if (A == nullptr) &#123; return false; &#125; return A-&gt;val == B-&gt;val &amp;&amp; isSame(A-&gt;left, B-&gt;left) &amp;&amp; isSame(A-&gt;right, B-&gt;right); &#125;&#125;; 剑指 Offer 27. 二叉树的镜像难度简单75收藏分享切换为英文接收动态反馈 请完成一个函数，输入一个二叉树，该函数输出它的镜像。 递归12345678910111213class Solution &#123;public: TreeNode* mirrorTree(TreeNode* root) &#123; if (root == nullptr) &#123; return root; &#125; swap(root-&gt;left, root-&gt;right); mirrorTree(root-&gt;left); mirrorTree(root-&gt;right); return root; &#125;&#125;; 迭代12345678910111213141516171819202122class Solution &#123;public: TreeNode* mirrorTree(TreeNode* root) &#123; if (root == nullptr) &#123; return root; &#125; stack&lt;TreeNode*&gt; stk; stk.push(root); while (!stk.empty()) &#123; TreeNode* tmp = stk.top(); stk.pop(); swap(tmp-&gt;left, tmp-&gt;right); if (tmp-&gt;left != nullptr) &#123; stk.push(tmp-&gt;left); &#125; if (tmp-&gt;right != nullptr) &#123; stk.push(tmp-&gt;right); &#125; &#125; return root; &#125;&#125;; 剑指 Offer 28. 对称的二叉树难度简单87收藏分享切换为英文接收动态反馈 请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的 递归1234567891011121314151617181920212223class Solution &#123;public: bool isSymmetric(TreeNode* root) &#123; if (root == nullptr) &#123; return true; &#125; return helper(root-&gt;left, root-&gt;right); &#125; bool helper(TreeNode* l, TreeNode* r) &#123; if (l == nullptr &amp;&amp; r == nullptr) &#123; return true; &#125; else if (l == nullptr || r == nullptr)&#123; return false; &#125; if (l-&gt;val == r-&gt;val &amp;&amp; helper(l-&gt;left, r-&gt;right) &amp;&amp; helper(l-&gt;right, r-&gt;left)) &#123; return true; &#125; else &#123; return false; &#125; &#125;&#125;; 迭代12345678910111213141516171819202122232425262728class Solution &#123;public: bool isSymmetric(TreeNode* root) &#123; if (root == nullptr) &#123; return true; &#125; stack&lt;TreeNode*&gt; stk; stk.push(root-&gt;left); stk.push(root-&gt;right); while (!stk.empty()) &#123; TreeNode* l = stk.top(); stk.pop(); TreeNode* r = stk.top(); stk.pop(); if (l == nullptr &amp;&amp; r == nullptr) &#123; continue; &#125; else if (l == nullptr || r == nullptr || l-&gt;val != r-&gt;val) &#123; return false; &#125; stk.push(l-&gt;left); stk.push(r-&gt;right); stk.push(l-&gt;right); stk.push(r-&gt;left); &#125; return true; &#125;&#125;; 剑指 Offer 55 - I. 二叉树的深度难度简单57收藏分享切换为英文接收动态反馈 输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度 递归123456789class Solution &#123;public: int maxDepth(TreeNode* root) &#123; if (root == nullptr) &#123; return 0; &#125; return 1 + max(maxDepth(root-&gt;left), maxDepth(root-&gt;right)); &#125;&#125;; 迭代：先序遍历123456789101112131415161718192021222324252627class Solution &#123;public: int maxDepth(TreeNode* root) &#123; if (root == nullptr) &#123; return 0; &#125; stack&lt;pair&lt;TreeNode*, int&gt;&gt; stk; stk.push(&#123;root, 1&#125;); int h = 0; while (!stk.empty()) &#123; pair&lt;TreeNode*, int&gt; p = stk.top(); stk.pop(); h = max(h, p.second); if (p.first-&gt;right) &#123; stk.push(&#123;p.first-&gt;right, p.second + 1&#125;); &#125; if (p.first-&gt;left) &#123; stk.push(&#123;p.first-&gt;left, p.second + 1&#125;); &#125; &#125; return h; &#125;&#125;; 剑指 Offer 55 - II. 平衡二叉树难度简单75收藏分享切换为英文接收动态反馈 输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。 1234567891011121314151617181920212223class Solution &#123;public: bool isBalanced(TreeNode* root) &#123; if (root == nullptr) &#123; return true; &#125; return treeHeight(root) &gt;= 0; &#125; int treeHeight(TreeNode* root) &#123; if (root == nullptr) &#123; return 0; &#125; int leftHeight = treeHeight(root-&gt;left); int rightHeight = treeHeight(root-&gt;right); if (leftHeight &gt;= 0 &amp;&amp; rightHeight &gt;= 0 &amp;&amp; abs(leftHeight - rightHeight) &lt;= 1) &#123; return max(leftHeight, rightHeight) + 1; &#125; else &#123; return -1; &#125; &#125;&#125;; 剑指 Offer 68 - II. 二叉树的最近公共祖先难度简单144收藏分享切换为英文接收动态反馈 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 1234567891011121314151617181920212223class Solution &#123;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; if (root == nullptr) &#123; return root; &#125; if (p == root || q == root) &#123; return root; &#125; TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q); TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q); //假如传入的p,q不一定都在root里面，那么只要任意一个p或q存在，就返回那个节点 if (left == nullptr &amp;&amp; right == nullptr) &#123; return nullptr; &#125; else if (left != nullptr &amp;&amp; right == nullptr) &#123; return left; &#125; else if (left == nullptr &amp;&amp; right != nullptr) &#123; return right; &#125; else &#123; return root; &#125; &#125;&#125;; 剑指 Offer 68 - I. 二叉搜索树的最近公共祖先难度简单61收藏分享切换为英文接收动态反馈 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。 1234567891011121314151617class Solution &#123;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; if (root == nullptr) &#123; return nullptr; &#125; if (root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val &gt; q-&gt;val) &#123; return lowestCommonAncestor(root-&gt;left, p, q); &#125; if (root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val) &#123; return lowestCommonAncestor(root-&gt;right, p, q); &#125; // p，q各在一边，或者pq为root， 说明当前的根就是最近共同祖先 return root; &#125;&#125;; 剑指 Offer 54. 二叉搜索树的第k大节点难度简单69收藏分享切换为英文接收动态反馈 给定一棵二叉搜索树，请找出其中第k大的节点。 12345678910111213141516171819202122class Solution &#123;public: int kthLargest(TreeNode* root, int k) &#123; TreeNode* node = root; int ans; int cnt = 0; mid(root, ans, cnt, k); return ans; &#125; void mid(TreeNode* root, int&amp; ans, int&amp; cnt, int k) &#123; if (root == nullptr) &#123; return; &#125; mid(root-&gt;right, ans, cnt, k); if (++cnt == k) &#123; ans = root-&gt;val; return; &#125; mid(root-&gt;left, ans, cnt, k); &#125; 剑指 Offer 32 - III. 从上到下打印二叉树 III难度中等48收藏分享切换为英文接收动态反馈 请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。 bfs1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; if (root == nullptr) &#123; return &#123;&#125;; &#125; deque&lt;TreeNode*&gt; q; vector&lt;vector&lt;int&gt;&gt; res; q.push_back(root); while (!q.empty()) &#123; vector&lt;int&gt; path; int size = q.size(); for (int i = 0; i &lt; size; i++) &#123; TreeNode* node = q.front(); path.push_back(node-&gt;val); q.pop_front(); if (node-&gt;left) &#123; q.push_back(node-&gt;left); &#125; if (node-&gt;right) &#123; q.push_back(node-&gt;right); &#125; &#125; res.push_back(path); if (q.empty()) &#123; break; &#125; path.clear(); size = q.size(); for (int i = 0; i &lt; size; i++) &#123; TreeNode* node = q.back(); path.push_back(node-&gt;val); q.pop_back(); if (node-&gt;right) &#123; q.push_front(node-&gt;right); &#125; if (node-&gt;left) &#123; q.push_front(node-&gt;left); &#125; &#125; res.push_back(path); &#125; return res; &#125;&#125;; 剑指 Offer 34. 二叉树中和为某一值的路径难度中等96收藏分享切换为英文接收动态反馈 输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。 回溯123456789101112131415161718192021222324252627282930class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int sum) &#123; if (root == nullptr) &#123; return &#123;&#125;; &#125; vector&lt;int&gt; path; vector&lt;vector&lt;int&gt;&gt; res; dfs(root, path, res, sum); return res; &#125; void dfs(TreeNode* root, vector&lt;int&gt;&amp; path, vector&lt;vector&lt;int&gt;&gt;&amp; res, int sum) &#123; path.push_back(root-&gt;val); if (accumulate(path.begin(), path.end(), 0) == sum &amp;&amp; root-&gt;left == nullptr &amp;&amp; root-&gt;right == nullptr) &#123; res.push_back(path); return; &#125; if (root-&gt;left) &#123; dfs(root-&gt;left, path, res, sum); path.pop_back(); &#125; if (root-&gt;right) &#123; dfs(root-&gt;right, path, res, sum); path.pop_back(); &#125; &#125;&#125;; 114. 二叉树展开为链表难度中等428 给定一个二叉树，原地将它展开为一个单链表。 总结后序遍历变形 递归12345678910111213141516class Solution &#123;public: // 变形的后序遍历，遍历顺序是右子树-&gt;左子树-&gt;根节点。 // 每遍历一个节点就将当前节点的右指针更新为上一个节点。 TreeNode* pre =nullptr; void flatten(TreeNode* root) &#123; if (root == nullptr) &#123; return; &#125; flatten(root-&gt;right); flatten(root-&gt;left); root-&gt;right = pre; root-&gt;left = nullptr; pre = root; &#125;&#125;; 迭代1234567891011121314151617181920212223242526272829303132class Solution &#123;public: void flatten(TreeNode* root) &#123; vector&lt;int&gt; res; stack&lt;TreeNode*&gt; call; if (root != nullptr) &#123; call.push(root); &#125; TreeNode* pre = nullptr; while (!call.empty()) &#123; TreeNode* cur = call.top(); call.pop(); if (cur != nullptr) &#123; call.push(cur); call.push(nullptr); if (cur-&gt;left) &#123; call.push(cur-&gt;left); &#125; if (cur-&gt;right) &#123; call.push(cur-&gt;right); &#125; &#125; else &#123; call.top()-&gt;right = pre; call.top()-&gt;left = nullptr; pre = call.top(); call.pop(); &#125; &#125; &#125;&#125;; 257. 二叉树的所有路径难度简单350收藏分享切换为英文关注反馈 给定一个二叉树，返回所有从根节点到叶子节点的路径。 123456789101112131415161718192021222324class Solution &#123;public: vector&lt;string&gt; binaryTreePaths(TreeNode* root) &#123; vector&lt;string&gt; res; if (root == nullptr) &#123; return res; &#125; dfs(root, "", res); return res; &#125; void dfs(TreeNode* root, string path, vector&lt;string&gt;&amp; res) &#123; if (root == nullptr) &#123; res.push_back(path); return; &#125; path += to_string(root-&gt;val); dfs(root-&gt;left, path + "-&gt;", res); dfs(root-&gt;right, path + "-&gt;", res); &#125;&#125;; 总结 隐式回溯和回溯对比，path传值而不是引用，通过参数传递的方式，就没有显式的回溯和状态重置的过程了 注意退出条件 to_string（） 链表 链表必记 反转链表怎么写 总结 需要返回头节点的，通常需要dummynode方便返回dummy-&gt;next 删除节点的。需要考虑头节点被删除的情况，也需要dummy node 一些范式 lc2和lc21的while(h1||h2) 反转链表 快慢指针找到中点lc134,lc141 1234567891011// 偶数个节点时，中点有两个时，返回第二个while (fast != nullptr &amp;&amp; fast-&gt;next != nullptr) &#123; fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; &#125;// 偶数个节点时，中点有两个时，返回第一个while (fast-&gt;next != nullptr &amp;&amp; fast-&gt;next-&gt;next != nullptr) &#123; fast = fast-&gt;next-&gt;next; slow = slow-&gt;next;&#125; 1. 偶数个节点时，中点有两个时，返回第一个 2. 偶数个节点时，中点有两个时，返回第二个 1 链表 # 题名 难度 2 两数相加 中等 19 删除链表的倒数第N个节点 中等 21 合并两个有序链表 简单 dummynode 23 合并K个升序链表 困难 141 环形链表 简单 142 环形链表 II 中等 148 排序链表 中等 160 相交链表 简单 206 反转链表 简单 234 回文链表 简单 剑指 Offer 24. 反转链表难度简单88 定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。 小结 画图 别忘了递归 思考边界（退出）条件，最后考虑是否可以去掉（隐含在后面的情况里了） 递归123456789101112131415class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; // 需要特判head-&gt;next == nullptr，因为下面有head-&gt;next-&gt;next = head; if (head == nullptr || head-&gt;next == nullptr) &#123; return head; &#125; ListNode* res = reverseList(head-&gt;next); head-&gt;next-&gt;next = head; // head-&gt;next = nullptr别忘了 head-&gt;next = nullptr; return res; &#125;&#125;; 迭代12345678910111213141516171819202122class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; if (head == nullptr || head-&gt;next == nullptr) &#123; return head; &#125; ListNode* cur = head; ListNode* prev = nullptr; while (cur) &#123; // 1-&gt;2-&gt;3-&gt;4 // 1&lt;-2 3-&gt;4 // 1&lt;-2&lt;-3 4 ListNode* next = cur-&gt;next; // 从这个核心步骤开始写 cur-&gt;next = prev; // 第1步 prev = cur; // 第2步 cur = next; // 第3部：cur = cur-&gt;next，可是改变了，所以需要提前用next存起来 &#125; return prev; &#125;&#125;; 剑指 Offer 22. 链表中倒数第k个节点难度简单73收藏分享切换为英文关注反馈 输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。 快慢指针1234567891011121314151617181920class Solution &#123;public: ListNode* getKthFromEnd(ListNode* head, int k) &#123; ListNode* fast = head; ListNode* slow = head; // 在无非法输入的情况，不用担心越界 for (int i = 0; i &lt; k; i++) &#123; fast = fast-&gt;next; &#125; // 注意fast-&gt;next为空和fast为空相差1 while (fast != nullptr) &#123; fast = fast-&gt;next; slow = slow-&gt;next; &#125; return slow; &#125;&#125;; 876. 链表的中间结点难度简单247收藏分享切换为英文关注反馈 给定一个带有头结点 head 的非空单链表，返回链表的中间结点。 如果有两个中间结点，则返回第二个中间结点。 重要123456789101112131415161718192021class Solution &#123;public: ListNode* middleNode(ListNode* head) &#123; if (head == nullptr) &#123; return nullptr; &#125; ListNode* slow = head; ListNode* fast = head; // 关键步骤，fast-&gt;next != nullptr就够了 // 可以允许fast-&gt;next-&gt;next == nullptr，但是用fast != nullptr保证这是末尾 while (fast != nullptr &amp;&amp; fast-&gt;next != nullptr) &#123; fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; &#125; return slow; &#125;&#125;; 剑指 Offer 06. 从尾到头打印链表难度简单51 输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。 反转数组1234567891011121314151617class Solution &#123;public: vector&lt;int&gt; reversePrint(ListNode* head) &#123; vector&lt;int&gt; res; if (head == nullptr) &#123; return res; &#125; ListNode* cur = head; while (cur) &#123; res.push_back(cur-&gt;val); cur = cur-&gt;next; &#125; reverse(res.begin(), res.end()); return res; &#125;&#125;; 预先分配空间1234567891011121314151617181920212223class Solution &#123;public: vector&lt;int&gt; reversePrint(ListNode* head) &#123; if (head == nullptr) &#123; return &#123;&#125;; &#125; ListNode* cur = head; int cnt = 0; while (cur) &#123; cnt++; cur = cur-&gt;next; &#125; cur = head; vector&lt;int&gt; res(cnt); for (auto i = res.rbegin(); i != res.rend(); i++) &#123; *i = cur-&gt;val; cur = cur-&gt;next; &#125; return res; &#125;&#125;; 递归123456789101112131415161718192021class Solution &#123;public: // 声明一个全局变量 vector&lt;int&gt; res; vector&lt;int&gt; reversePrint(ListNode* head) &#123; if (head == nullptr) &#123; return &#123;&#125;; &#125; recur(head); return res; &#125; void recur(ListNode* head) &#123; if (head == nullptr) &#123; return; &#125; recur(head-&gt;next); res.push_back(head-&gt;val); &#125;&#125;; 剑指 Offer 35. 复杂链表的复制难度中等82收藏分享切换为英文关注反馈 请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。 123456789101112131415161718192021222324252627282930313233343536373839404142434445/*// Definition for a Node.class Node &#123;public: int val; Node* next; Node* random; Node(int _val) &#123; val = _val; next = NULL; random = NULL; &#125;&#125;;*/class Solution &#123;public: Node* copyRandomList(Node* head) &#123; if (head == NULL) &#123; return head; &#125; //将拷贝节点放到原节点后面，例如1-&gt;2-&gt;3这样的链表就变成了这样1-&gt;1'-&gt;2'-&gt;3-&gt;3' for (Node* node = head, *copy = NULL; node != NULL; node = node-&gt;next-&gt;next) &#123; copy = new Node(node-&gt;val); copy-&gt;next = node-&gt;next; node-&gt;next = copy; &#125; //把拷贝节点的random指针安排上 for (Node* node = head; node != NULL; node = node-&gt;next-&gt;next) &#123; if (node-&gt;random != NULL) &#123; node-&gt;next-&gt;random = node-&gt;random-&gt;next; &#125; &#125; //分离拷贝节点和原节点，变成1-&gt;2-&gt;3和1'-&gt;2'-&gt;3'两个链表，后者就是答案 Node* newHead = head-&gt;next; for (Node* node = head, * temp = NULL; node != NULL &amp;&amp; node-&gt;next != NULL;) &#123; temp = node-&gt;next; node-&gt;next = temp-&gt;next; node = temp; &#125; return newHead; &#125;&#125;; 小结 注意新建节点的写法 new 拷贝新节点放在原来的节点后面，省去哈系表 剑指 Offer 52. 两个链表的第一个公共节点难度简单89收藏分享切换为英文关注反馈 输入两个链表，找出它们的第一个公共节点。 双指针123456789101112131415161718192021222324class Solution &#123;public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123; ListNode* h1 = headA; ListNode* h2 = headB; // while的判断条件很重要，因为两个指针走的距离是相同的 // 所以无论是否相交，都在相等时退出 while (h1 != h2) &#123; if (h1 == nullptr) &#123; h1 = headB; &#125; else &#123; h1 = h1-&gt;next; &#125; if (h2 == nullptr) &#123; h2 = headA; &#125; else &#123; h2 = h2-&gt;next; &#125; &#125; return h1; &#125;&#125;; 小结注意退出条件 剑指 Offer 18. 删除链表的节点难度简单42收藏分享切换为英文关注反馈 给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。 返回删除后的链表的头节点。 123456789101112131415161718class Solution &#123;public: ListNode* deleteNode(ListNode* head, int val) &#123; ListNode* dummy = new ListNode(-1); dummy-&gt;next = head; ListNode* cur = dummy; // 注意判断条件，cur-&gt;next，否则在不存在节点时会报错 while (cur-&gt;next) &#123; if (cur-&gt;next-&gt;val == val) &#123; cur-&gt;next = cur-&gt;next-&gt;next; break; &#125; else &#123; cur = cur-&gt;next; &#125; &#125; return dummy-&gt;next; &#125;&#125;; 2. 两数相加难度中等4785收藏分享切换为英文关注反馈 给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 dummy node1234567891011121314151617181920212223242526class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode* h1 = l1; ListNode* h2 = l2; ListNode* dummy = new ListNode(-1); ListNode* cur = dummy; int carry = 0; while (h1 || h2 || carry) &#123; int sum = carry; if (h1) &#123; sum += h1-&gt;val; h1 = h1-&gt;next; &#125; if (h2) &#123; sum += h2-&gt;val; h2 = h2-&gt;next; &#125; cur-&gt;next = new ListNode (sum % 10); cur = cur-&gt;next; carry = sum / 10; &#125; return dummy-&gt;next; &#125;&#125;; 21. 合并两个有序链表难度简单1225收藏分享切换为英文关注反馈 将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 dummy node123456789101112131415161718192021222324252627282930313233343536/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) &#123;&#125; * ListNode(int x) : val(x), next(nullptr) &#123;&#125; * ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; ListNode* h1 = l1; ListNode* h2 = l2; ListNode* dummy = new ListNode(-1); ListNode* cur = dummy; while (h1 &amp;&amp; h2) &#123; if (h1-&gt;val &lt; h2-&gt;val) &#123; cur-&gt;next = h1; cur = cur-&gt;next; h1 = h1-&gt;next; &#125; else &#123; cur-&gt;next = h2; cur = cur-&gt;next; h2 = h2-&gt;next; &#125; &#125; if (h1 == nullptr) &#123; cur-&gt;next = h2; &#125; else if (h2 == nullptr) &#123; cur-&gt;next = h1; &#125; return dummy-&gt;next; &#125;&#125;; 19. 删除链表的倒数第N个节点难度中等951收藏分享切换为英文关注反馈 给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。 1234567891011121314151617181920212223242526class Solution &#123;public: ListNode* removeNthFromEnd(ListNode* head, int n) &#123; ListNode* fast = head; ListNode* dummy = new ListNode(-1); dummy-&gt;next = head; // 因为要删除节点，所以slow要找到倒数第n+1个节点 // 故slow从dummy开始，初始值就比fast少一步 ListNode* slow = dummy; // n = 2 // 1-&gt;2-&gt;3-&gt;4 // fast // slow for (int i = 0; i &lt; n; i++) &#123; fast = fast-&gt;next; &#125; while (fast) &#123; fast = fast-&gt;next; slow = slow-&gt;next; &#125; slow-&gt;next = slow-&gt;next-&gt;next; return dummy-&gt;next; &#125;&#125;; 141. 环形链表难度简单725收藏分享切换为英文关注反馈 给定一个链表，判断链表中是否有环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 123456789101112131415161718class Solution &#123;public: bool hasCycle(ListNode *head) &#123; if (head == nullptr) &#123; return false; &#125; ListNode* fast = head; ListNode* slow = head; while (fast != nullptr &amp;&amp; fast-&gt;next != nullptr) &#123; fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; if (fast == slow) &#123; return true; &#125; &#125; return false; &#125;&#125;; 142. 环形链表 II难度中等593收藏分享切换为英文关注反馈 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 123456789101112131415161718192021222324252627282930class Solution &#123;public: ListNode *detectCycle(ListNode *head) &#123; // 分两个步骤，首先通过快慢指针的方法判断链表是否有环； // 接下来如果有环，则寻找入环的第一个节点。 // 具体的方法为，首先假定链表起点到入环的第一个节点A的长度为a【未知】，到快慢指针相遇的节点B的长度为（a + b）【这个长度是已知的】。 // 现在我们想知道a的值，注意到快指针p2始终是慢指针p走过长度的2倍，所以慢指针p从B继续走（a + b）又能回到B点，如果只走a个长度就能回到节点A。 // 但是a的值是不知道的，解决思路是曲线救国，注意到起点到A的长度是a，那么可以用一个从起点开始的新指针q和从节点B开始的慢指针p同步走，相遇的地方必然是入环的第一个节点A。 ListNode* slow = head; ListNode* fast = head; bool hasCycle = false; while (fast &amp;&amp; fast-&gt;next) &#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; if (slow == fast) &#123; hasCycle = true; break; &#125; &#125; if (hasCycle == false) &#123; return nullptr; &#125; ListNode* innode = head; while (innode != slow) &#123; slow = slow-&gt;next; innode = innode-&gt;next; &#125; return innode; &#125;&#125;; 234. 回文链表难度简单608收藏分享切换为英文关注反馈 请判断一个链表是否为回文链表。 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123;public: bool isPalindrome(ListNode* head) &#123;//O(n)、O(1) if (head == nullptr) &#123; return true; &#125; ListNode* slow = head, *fast = head, *prev = nullptr; //find mid node while (fast-&gt;next != NULL &amp;&amp; fast-&gt;next-&gt;next != NULL)&#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; &#125; //reverse // case 0 // 1 -&gt; 2 -&gt; 2-&gt; 1 // slow // 1 -&gt; 2 &lt;- 2&lt;- 1 // head prev // case 1 // 1 -&gt; 2 -&gt; 1 // slow // 1 -&gt; 2 &lt;- 1 // head prev // 反转链表，不使用额外空间 while (slow)&#123; ListNode* next_node = slow-&gt;next; slow-&gt;next = prev; prev = slow; slow = next_node; &#125; //check 注意这里的判断条件 while (head)&#123; if (head-&gt;val != prev-&gt;val)&#123; return false; &#125; head = head-&gt;next; prev = prev-&gt;next; &#125; return true; &#125;&#125;; 2. 两数相加使用carry进位难度中等4647 给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode* h1 = l1; ListNode* h2 = l2; int carry = 0; ListNode* dummy = new ListNode(-1); ListNode* ptr = dummy; while (h1 != nullptr || h2 != nullptr) &#123; int val = carry; if (h1) &#123; val += h1-&gt;val; h1 = h1-&gt;next; &#125; if (h2) &#123; val += h2-&gt;val; h2 = h2-&gt;next; &#125; carry = val / 10; val = val % 10; ptr-&gt;next = new ListNode(val); ptr = ptr-&gt;next; &#125; if (carry != 0) &#123; ptr-&gt;next = new ListNode(carry); &#125; return dummy-&gt;next; &#125;&#125;; 234. 回文链表难度简单572 请判断一个链表是否为回文链表。 将链表的后半部分反转123456789101112131415161718192021222324class Solution &#123;public: bool isPalindrome(ListNode* head) &#123;//O(n)、O(1) ListNode* slow = head, *fast = head, *prev = nullptr; while (fast)&#123;//find mid node slow = slow-&gt;next; fast = fast-&gt;next ? fast-&gt;next-&gt;next: fast-&gt;next; &#125; while (slow)&#123;//reverse ListNode* next_node = slow-&gt;next; slow-&gt;next = prev; prev = slow; slow = next_node; &#125; while (head &amp;&amp; prev)&#123;//check if (head-&gt;val != prev-&gt;val)&#123; return false; &#125; head = head-&gt;next; prev = prev-&gt;next; &#125; return true; &#125;&#125;; 160. 相交链表难度简单738收藏分享切换为英文关注反馈 编写一个程序，找到两个单链表相交的起始节点。 到达末尾指向另一链表头12345678910111213141516171819class Solution &#123;public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123; // 若相交，链表A： a+c, 链表B : b+c. a+c+b+c = b+c+a+c 。则会在公共处c起点相遇。 // 若不相交，a +b = b+a 。因此相遇处是NULL if (headA == nullptr || headB == nullptr) &#123; return nullptr; &#125; ListNode* hA = headA; ListNode* hB = headB; while (hA != hB) &#123; hA = hA == nullptr ? headB : hA-&gt;next; hB = hB == nullptr ? headA : hB-&gt;next; &#125; return hA; &#125;&#125;; 148. 排序链表难度中等647收藏分享切换为英文关注反馈 在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。 bottom-to-up 双路归并1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */// merge(l1, l2)，双路归并// cut(l, n)，断链操作，将链表 l 切掉前 n 个节点，并返回后半部分的链表头。// dummyHeadclass Solution &#123;public: ListNode* sortList(ListNode* head) &#123; ListNode dummyHead(0); dummyHead.next = head; // 确定链表长度 ListNode* p = head; int length = 0; while (p) &#123; length++; p = p-&gt;next; &#125; for (int size= 1; size &lt; length; size &lt;&lt;= 1) &#123; ListNode* cur = dummyHead.next; ListNode* tail = &amp;dummyHead; while (cur) &#123; ListNode* left = cur; ListNode* right = cut(left, size); cur = cut(right, size); tail-&gt;next = merge(left, right); while (tail-&gt;next) &#123; tail = tail-&gt;next; &#125; &#125; &#125; return dummyHead.next; &#125; ListNode* cut(ListNode* head, int n) &#123; ListNode* p = head; while (--n &amp;&amp; p) &#123; p = p-&gt;next; &#125; if (!p) &#123; return nullptr; &#125; ListNode* next = p-&gt;next; p-&gt;next = nullptr; return next; &#125; ListNode* merge(ListNode* l1, ListNode* l2) &#123; ListNode dummyHead(0); ListNode* p = &amp;dummyHead; while (l1 &amp;&amp; l2) &#123; if (l1-&gt;val &lt; l2-&gt;val) &#123; p-&gt;next = l1; p = l1; l1 = l1-&gt;next; &#125; else &#123; p-&gt;next = l2; p = l2; l2 = l2-&gt;next; &#125; &#125; p-&gt;next = l1 ? l1 : l2; return dummyHead.next; &#125;&#125;; 并查集547. 朋友圈难度中等289收藏分享切换为英文关注反馈 班上有 N 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。所谓的朋友圈，是指所有朋友的集合。 路径压缩（隔代压缩1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution &#123;public: vector&lt;int&gt; fathers; int find(int i) &#123; while (fathers[i] != i) &#123; // 隔代压缩 fathers[i] = fathers[fathers[i]]; i = fathers[i]; &#125; return i; &#125; void uni(int i, int j) &#123; int f1 = find(i); int f2 = find(j); fathers[f1] = f2; &#125; int findCircleNum(vector&lt;vector&lt;int&gt;&gt;&amp; M) &#123; if (M.size() == 0) &#123; return 0; &#125; int n = M.size(); // 初始化父节点 for (int i = 0; i &lt; n; i++) &#123; fathers.push_back(i); &#125; for (int i = 0 ; i &lt; n; i++) &#123; // 上三角 for (int j = i + 1; j &lt; n; j++) &#123; if (M[i][j] == 1) &#123; uni(i, j); &#125; &#125; &#125; int cnt = 0; for (int i = 0; i &lt; n; i++) &#123; if (fathers[i] == i) &#123; cnt++; &#125; &#125; return cnt; &#125;&#125;; 按秩合并123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class Solution &#123;public: vector&lt;int&gt; fathers; vector&lt;int&gt; rank; int find(int i) &#123; while (i != fathers[i]) &#123; i = fathers[i]; &#125; return i; &#125; // 按秩合并 void uni(int i, int j) &#123; int f1 = find(i); int f2 = find(j); if (rank[f1] == rank[f2]) &#123; fathers[f2] = f1; rank[f1]++; &#125; else if (rank[f2] &lt; rank[f1]) &#123; fathers[f2] = f1; &#125; if (rank[f2] &gt; rank[f1]) &#123; fathers[f1] = f2; &#125; &#125; int findCircleNum(vector&lt;vector&lt;int&gt;&gt;&amp; M) &#123; int n = M.size(); if (n == 0) &#123; return 0; &#125; for (int i = 0; i &lt; n; i++) &#123; fathers.push_back(i); rank.push_back(1); &#125; // 遍历上三角即可 for (int i = 0; i &lt; n; i++) &#123; for (int j = i + 1; j &lt; n; j++) &#123; if (M[i][j] == 1) &#123; uni(i, j); &#125; &#125; &#125; int cnt = 0; for (int i = 0; i &lt; n; i++) &#123; if (i == fathers[i]) &#123; cnt++; &#125; &#125; return cnt; &#125;&#125;; 小结 用「隔代压缩」，代码比较好写。不写「按秩合并」，除非题目有一些关于「秩」的信息需要讨论。一般来说，这样写也能得到不错的性能，如果性能不太好的话，再考虑「按秩合并」。 路径压缩（隔代压缩）worst case n^2 优化到nlogn 200. 岛屿数量难度中等706收藏分享切换为英文关注反馈 给你一个由 &#39;1&#39;（陆地）和 &#39;0&#39;（水）组成的的二维网格，请你计算网格中岛屿的数量。 岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。 此外，你可以假设该网格的四条边均被水包围。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Solution &#123;public: vector&lt;int&gt; fathers; int find(int i) &#123; while (i != fathers[i]) &#123; fathers[i] = fathers[fathers[i]]; i = fathers[i]; &#125; return i; &#125; void uni(int i, int j) &#123; int f1 = find(i); int f2 = find(j); // 注意真正的含义，别写成f1 = fathers[f2]; fathers[f2] = f1; &#125; int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123; if (grid.size() == 0 || grid[0].size() == 0) &#123; return 0; &#125; int m = grid.size(); int n = grid[0].size(); for (int i = 0; i &lt; m * n; i++) &#123; fathers.push_back(i); &#125; for (int i = 0; i &lt; m; i ++) &#123; for (int j = 0; j &lt; n; j++) &#123; int pos = j + n * i; if (grid[i][j] == '0') &#123; continue; &#125; else &#123; if (i &gt; 0 &amp;&amp; grid[i - 1][j] == '1') &#123; uni(pos, pos - n); &#125; if (j &gt; 0 &amp;&amp; grid[i][j - 1] == '1') &#123; uni(pos, pos - 1); &#125; &#125; &#125; &#125; int cnt = 0; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (grid[i][j] == '1' &amp;&amp; fathers[j + i * n] == j + i * n) &#123; cnt++; &#125; &#125; &#125; return cnt; &#125;&#125;;x 130. 被围绕的区域难度中等350收藏分享切换为英文关注反馈 给定一个二维的矩阵，包含 &#39;X&#39; 和 &#39;O&#39;（字母 O）。i 找到所有被 &#39;X&#39; 围绕的区域，并将这些区域里所有的 &#39;O&#39; 用 &#39;X&#39; 填充。 并查集12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970class Solution &#123;public: vector&lt;int&gt; fathers; int find(int i) &#123; while (i != fathers[i]) &#123; i = fathers[i]; &#125; return i; &#125; void uni(int i, int j) &#123; int f1 = find(i); int f2 = find(j); fathers[f2] = f1; &#125; void solve(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; if (board.size() == 0) &#123; return; &#125; int m = board.size(); int n = board[0].size(); for (int i = 0; i &lt;= m * n; i++) &#123; fathers.push_back(i); &#125; int dummypos = m * n; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (board[i][j] == 'X') &#123; continue; &#125; int curpos = j + i * n; if (i == 0 || j == 0 || i == m - 1 || j == n - 1) &#123; uni(dummypos, curpos); continue; &#125; // 注意这里的右边和下边不能省略 if (board[i - 1][j] == 'O') &#123; uni(curpos, curpos - n); &#125; if (board[i][j - 1] == 'O') &#123; uni(curpos, curpos - 1); &#125; if (board[i + 1][j] == 'O') &#123; uni(curpos, curpos + n); &#125; if (board[i][j + 1] == 'O') &#123; uni(curpos, curpos + 1); &#125; &#125; &#125; int dummyfather = find(dummypos); for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; int curpos = j + i * n; if (board[i][j] == 'O' &amp;&amp; find(curpos) != dummyfather) &#123; board[i][j] = 'X'; &#125; &#125; &#125; return; &#125;&#125;; DFS12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution &#123;public: void dfs(int i, int j, int m, int n, vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; if (i &lt; 0 || i &gt;= m || j &lt; 0 || j &gt;= n || board[i][j] != 'O') &#123; return; &#125; board[i][j] = 'G'; // 与边界的O连通 dfs(i + 1, j, m, n, board); dfs(i - 1, j, m, n, board); dfs(i, j + 1, m, n, board); dfs(i, j - 1, m, n, board); &#125; void solve(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; if (board.size() == 0) &#123; return; &#125; const int m = board.size(); const int n = board[0].size(); for (int j = 0; j &lt; n; j++) &#123; dfs(0, j, m, n, board); dfs(m - 1, j, m, n, board); &#125; for (int i = 0; i &lt; m; i++) &#123; dfs(i, 0, m, n, board); dfs(i, n - 1, m, n, board); &#125; unordered_map&lt;char, char&gt; map&#123;&#123;'G', 'O'&#125;, &#123;'X', 'X'&#125;, &#123;'O', 'X'&#125;&#125;; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; board[i][j] = map[board[i][j]]; &#125; &#125; return; &#125;&#125;; 小结 注意这里的右边和下边不能省略，和200岛屿数量比较 周赛5474. 好叶子节点对的数量难度中等3 给你二叉树的根节点 root 和一个整数 distance 。 如果二叉树中两个 叶 节点之间的 最短路径长度 小于或者等于 distance ，那它们就可以构成一组 好叶子节点对 。 返回树中 好叶子节点对的数量 。 DFS12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public: int countPairs(TreeNode* root, int distance) &#123; int ans = 0; dfs(root, distance, ans); return ans; &#125; // 返回这个节点到其下方所有叶子节点的距离 vector&lt;int&gt; dfs(TreeNode* root, int distance, int&amp; ans) &#123; // 空节点 if (root == nullptr) &#123; return &#123;&#125;; &#125; // 叶子节点 if (root-&gt;left == nullptr &amp;&amp; root-&gt;right == nullptr) &#123; return &#123;0&#125;; &#125; vector&lt;int&gt; ret; vector&lt;int&gt; left = dfs(root-&gt;left, distance, ans); for (int&amp; e : left) &#123; if (++e &lt;= distance) &#123; ret.push_back(e); &#125; &#125; vector&lt;int&gt; right = dfs(root-&gt;right, distance, ans); for (int&amp; e : right) &#123; // 如果某一层上距离已经超过了distance那就把这个结点抛弃掉 if (++e &lt;= distance) &#123; ret.push_back(e); &#125; &#125; for (int l : left) &#123; for (int r : right) &#123; ans += (l + r) &lt;= distance; &#125; &#125; return ret; &#125;&#125;; 动态规划首先，需要对「子序列」和「子串」这两个概念进行区分； 子序列（subsequence）：子序列并不要求连续，例如：序列 [4, 6, 5] 是 [1, 2, 4, 3, 7, 6, 5] 的一个子序列；子串（substring、subarray）：子串一定是原始字符串的连续子串，例如：「力扣」第 3 题：无重复字符的最长子串，「力扣」第 53 题：最大子序和。其次，题目中的「上升」的意思是「严格上升」，[1, 2, 2, 3] 都不能算作「上升子序列」； liweiwei动态规划整理 https://leetcode-cn.com/problems/edit-distance/solution/dong-tai-gui-hua-java-by-liweiwei1419/ leetcode背包问题整理 https://leetcode-cn.com/problems/combination-sum-iv/solution/xi-wang-yong-yi-chong-gui-lu-gao-ding-bei-bao-wen-/ [[力扣] DP问题分类汇总][https://zhuanlan.zhihu.com/p/126546914?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=27134168924160] DP问题整理 选择问题：宝贝问题 序列问题：最长子序列模型 状态压缩 状态机 线性DP 区间DP 一维 二维 有限集中的最值：最大，最小，数量，存在与否 从定义枚举一般指数数量级 53. 最大子序和难度简单2557收藏分享切换为英文接收动态反馈 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 12345678910111213141516171819class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; if (nums.empty()) &#123; return 0; &#125; int res = nums[0]; int dp = nums[0]; for (int i = 1; i &lt; nums.size(); i++) &#123; if (dp &gt; 0) &#123; dp += nums[i]; &#125; else &#123; dp = nums[i]; &#125; res = max(res, dp); &#125; return res; &#125;&#125;; 小结 空间复杂度优化到O(1) 300. 最长上升子序列难度中等1104收藏分享切换为英文接收动态反馈 给定一个无序的整数数组，找到其中最长上升子序列的长度。 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123; if (nums.empty()) &#123; return 0; &#125; int len = nums.size(); vector&lt;int&gt; tail(len); tail[0] = nums[0]; int end_idx = 0; for (int i = 1; i &lt; len; i++) &#123; if (nums[i] &gt; tail[end_idx]) &#123; end_idx++; tail[end_idx] = nums[i]; &#125; else &#123; int left = 0; int right = end_idx; while (left &lt; right) &#123; int mid = left + (right - left) / 2; if (tail[mid] &lt; nums[i]) &#123; left = mid + 1; &#125; else &#123; right = mid; &#125; &#125; tail[left] = nums[i]; &#125; &#125; end_idx++; return end_idx; &#125;&#125;; 小结 要把复杂度优化到o(nlogn),o(nlogn)想到二分 闫氏DP分析法 状态表示f[i]:化0为整 集合 属性：通常存的是一个数，这个数存的是 max min count 状态计算：集合划分，化整为0 f[i]划分成若干个子集分别求，最后合起来 划分原则：“寻找最后一个不同点” 原则：不重复（不一定需要）；不遗漏（必须） ACWING2 01背包问题二维1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;const int N = 1010;int v[N], w[N];int dp[N][N];int main()&#123; int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; v[i] &gt;&gt; w[i]; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 0; j &lt;= m; j++) &#123; dp[i][j] = dp[i - 1][j]; if (j &gt;= v[i]) &#123; dp[i][j] = max(dp[i][j], dp[i - 1][j - v[i]] + w[i]); &#125; &#125; &#125; cout &lt;&lt; dp[n][m]; return 0;&#125; 一维1234567891011121314151617181920212223#include&lt;iostream&gt;using namespace std;const int N = 1010;int n, m;int v[N], w[N];int f[N];int main()&#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; v[i] &gt;&gt; w[i]; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = m; j &gt;= v[i]; j--) &#123; // 看到，f[i]要用到上一级中序号比自己小的数，所以得从后往前遍历 f[j] = max(f[j], f[j - v[i]] + w[i]); &#125; &#125; cout &lt;&lt; f[m] &lt;&lt; endl;&#125; 416. 分割等和子集(01背包)难度中等285 给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。 c++ 2维DP版本112345678910111213141516171819202122232425262728class Solution &#123;public: bool canPartition(vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); int sum = accumulate(nums.begin(), nums.end(), 0); if (sum &amp; 1) &#123; return false; &#125; int target = sum / 2; vector&lt;vector&lt;int&gt;&gt; dp(len, vector&lt;int&gt; (target + 1, 0)); if (nums[0] &lt;= target) &#123; dp[0][nums[0]] = 1; &#125; for (int i = 1; i &lt; len; i++) &#123; for (int j = 0; j &lt;= target; j++) &#123; dp[i][j] = dp[i - 1][j]; if (j &gt;= nums[i]) &#123; dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i]]; &#125; &#125; &#125; return dp[len - 1][target]; &#125;&#125;; c++ 2维DP版本2123456789101112131415161718192021222324252627class Solution &#123;public: bool canPartition(vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); int sum = accumulate(nums.begin(), nums.end(), 0); if (sum &amp; 1) &#123; return false; &#125; int target = sum / 2; // dp尺寸是 (len + 1) * target //第一行作为辅助，要仔细初始化 vector&lt;vector&lt;int&gt;&gt; dp(len + 1, vector&lt;int&gt; (target + 1, 0)); dp[0][0] = 1; for (int i = 1; i &lt;= len; i++) &#123; for (int j = 0; j &lt;= target; j++) &#123; dp[i][j] = dp[i - 1][j]; // 注意nums不是从1开始的，故序号减1 if (j &gt;= nums[i - 1]) &#123; dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i - 1]]; &#125; &#125; &#125; return dp[len][target]; &#125;&#125;; c++一维DP1234567891011121314151617181920212223242526272829class Solution &#123;public: bool canPartition(vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); // 注意第3个参数 int sum = accumulate(nums.begin(), nums.end(), 0); // 和为奇数不可能分两份 if (sum &amp; 1) &#123; return false; &#125; int target = sum / 2; vector&lt;int&gt; dp(target + 1, 0);// i的范围0到len - 1，j的范围0到target // 第一行，nums：0-0范围的数，只有和为num[0]为true if (nums[0] &lt;= target) &#123; dp[nums[0]] = 1; &#125; // dp(i, s) : 是否存在：nums区间[0, i] 中取一些元素，使其和为s // dp(i, s) = d(i-1, s)&#123;不取nums[i]&#125; || d(i-1, s-nums[i])&#123;取nums[i]&#125; for (int i = 1; i &lt; len; i++) &#123; for (int j = target; j &gt;= nums[i]; j--) &#123; dp[j] = dp[j] || dp[j - nums[i]]; &#125; &#125; return dp[target]; &#125;&#125;; ACWING3 完全背包问题一维1234567891011121314151617181920212223#include &lt;iostream&gt;using namespace std;const int N = 1010;int v[N], w[N];int dp[N];int main()&#123; int n, m; cin &gt;&gt;n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; v[i] &gt;&gt; w[i]; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = v[i]; j &lt;= m; j++) &#123; dp[j] = max(dp[j], dp[j - v[i]] + w[i]); &#125; &#125; cout &lt;&lt; dp[m]; return 0;&#125; 二维1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;const int N = 1010;int v[N], w[N];int dp[N][N];int main()&#123; int n, m; cin &gt;&gt;n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; v[i] &gt;&gt; w[i]; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 0; j &lt;= m; j++) &#123; dp[i][j] = dp[i - 1][j]; if (j &gt;= v[i]) &#123; dp[i][j] = max(dp[i][j], dp[i][j - v[i]] + w[i]); &#125; &#125; &#125; cout &lt;&lt; dp[n][m]; return 0;&#125; (二维背包)474. 一和零难度中等158 在计算机界中，我们总是追求用有限的资源获取最大的收益。 现在，假设你分别支配着 m 个 0 和 n 个 1。另外，还有一个仅包含 0 和 1 字符串的数组。 你的任务是使用给定的 m 个 0 和 n 个 1 ，找到能拼出存在于数组中的字符串的最大数量。每个 0 和 1 至多被使用一次。 322. 零钱兑换难度中等615 给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。 c++ 二维12345678910111213141516171819202122232425262728293031class Solution &#123;public: int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123; int n = coins.size(); vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt; (amount + 1, amount + 1)); dp[0][0] = 0; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 0; j &lt;= amount; j++) &#123; dp[i][j] = dp[i - 1][j]; if (j &gt;= coins[i - 1]) &#123; dp[i][j] = min(dp[i][j], dp[i][j - coins[i - 1]] + 1); &#125; &#125; &#125; for (int i = 0; i &lt;= n; i++) &#123; for (int j = 0; j &lt;= amount; j++) &#123; cout &lt;&lt; dp[i][j] &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; if (dp[n][amount] == amount + 1) &#123; return -1; &#125; else &#123; return dp[n][amount]; &#125; &#125;&#125;; c++ 一维1234567891011121314151617181920212223242526class Solution &#123;public: int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123; // 转化为完全背包问题 “所占空间”v[i]为coins[i - 1] “价值”w[i] = 1，求最小 // dp[i][j]代表前i种硬币，恰好等与j的最小硬币数 int n = coins.size(); // 设置amount + 1代表不存在硬币数满足 vector&lt;int&gt; dp(amount + 1, amount + 1); dp[0] = 0; for (int i = 1; i &lt;= n; i++) &#123; for (int j = coins[i - 1]; j &lt;= amount; j++) &#123; // 只有dp[j - coins[i - 1]]存在时它+1才可能比dp[j]小 dp[j] = min(dp[j], dp[j - coins[i - 1]] + 1); &#125; &#125; if (dp[amount] == amount + 1) &#123; return -1; &#125; else &#123; return dp[amount]; &#125; &#125;&#125;; ACWING282 石子合并1234567891011121314n = int(input())f = [[0 for _ in range(310)] for _ in range(310)]nums = [0] + list(map(int, input().split()))s = [0]for i in range(1, n+1): s.append(s[-1]+nums[i])for l in range(2, n + 1): for i in range(1, n - l + 2): j = i + l - 1 f[i][j] = float('inf') for k in range(i, j): f[i][j] = min(f[i][j], f[i][k] + f[k + 1][j] + s[j] - s[i - 1])print(f[1][n]) 53. 最大子序和难度简单1814 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 注意：可以先用数组，然后优化 123456789101112131415161718192021222324class Solution: def maxSubArray(self, nums: List[int]) -&gt; int: # sum_current代表以当前为末尾的最大子序和，两种情况 # 1上一个位置为末尾的最大子序和小于0，则最大子序就只有该位置一个数 # 2大于0，则最大子序加上该位置的数 # 例子：1 -3 -2 # 1 &gt; 0 故-3为末尾的最大子序为1 + -3 = -2，而以-2为末尾的最大子仅为-2 # ans代表当前位置之前的最大子序和 # 遍历每个位置，当前位置之前的最大子序和有两种情况，取max # 1不包括当前位置，那么就等于上一个位置以前的最大子序和ans # 2包括当前位置的数，那么就等于以当前位置的数为末尾的最大子序和 sum_current = 0 ans = nums[0] for i in range(len(nums)): # 更讨巧的办法 sum_current = max(sum_current, 0) + nums[i] # if sum_current &lt; 0: # sum_current = nums[i] # else: # sum_current += nums[i] ans = max(sum_current, ans) return ans 120. 三角形最小路径和难度中等360 给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。 例如，给定三角形： 12345678910111213141516171819202122232425class Solution: def minimumTotal(self, triangle: List[List[int]]) -&gt; int: # 读入第一个数，行数N # f = [[float('inf') for _ in range(n)] for _ in range(n)] # 省空间 f = [[float('inf') for _ in range(n)] for _ in range(2)] f[0][0] = triangle[0][0] for i in range(1, n): # 注意列的右边界 for j in range(i + 1): # 位运算里的与1等与mod2 # 这种写法能把代码改动最小的情况下写成省空间的做法 f[i &amp; 1][j] = float('inf') if j &gt; 0: f[i &amp; 1][j] = min(f[i &amp; 1][j], f[(i - 1) &amp; 1][j - 1] + \ triangle[i][j]) # 注意j的右边界 if j &lt; i: f[i &amp; 1][j] = min(f[i &amp; 1][j], f[(i - 1) &amp; 1][j] + triangle\ [i][j]) res = float('inf') for j in range(n): res = min(res, f[(n - 1) &amp; 1][j]) return res 63. 不同路径 II难度中等265 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？ 1234567891011121314151617181920212223242526272829class Solution: def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -&gt; int: m = len(obstacleGrid) n = len(obstacleGrid[0]) # dp = [[0 for _ in range(n)] for _ in range(m)] dp = [0 for _ in range(n)] for i in range(m): for j in range(n): if obstacleGrid[i][j] == 1: dp[j] = 0 elif i == 0 and j == 0: # dp[i][j] = 1 dp[j] = 1 # elif i == 0: # dp[i][j] = dp[i][j - 1] # elif j == 0: # dp[i][j] = dp[i - 1][j] # else: # dp[i][j] = dp[i][j - 1] + dp[i - 1][j] # 少一个判断的写法 elif j &gt; 0: # dp[i][j] += dp[i][j - 1] dp[j] += dp[j - 1] # if i &gt; 0: # dp[i][j] += dp[i - 1][j] # dp[j] += dp[j] return dp[n - 1] # return dp[n - 1] 123456789101112131415161718192021222324252627class Solution: def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -&gt; int: m = len(obstacleGrid) n = len(obstacleGrid[0]) # if m == 1 and n == 1 and obstacleGrid[0][0] == 1: # return 0 # f = [[0 for _ in range(n)] for _ in range(m)] # f[0][0] = 1 if obstacleGrid[0][0] == 0 else 0 # for i in range(m): # for j in range(n): # if obstacleGrid[i][j] == 0: # if i &gt; 0: # f[i][j] += f[i - 1][j] # if j &gt; 0: # f[i][j] += f[i][j - 1] # return f[m - 1][n - 1] f = [0 for _ in range(n)] f[0] = 1 if obstacleGrid[0][0] == 0 else 0 for i in range(m): for j in range(n): # 此处是关键，若该位置未障碍，则需要改为0，而不能直接跳过不管 if obstacleGrid[i][j] == 1: f[j] = 0 else: if j &gt; 0: f[j] += f[j - 1] return f[n - 1] 62. 不同路径难度中等491 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 问总共有多少条不同的路径？ 注意动态规划最后要看一下，空间可不可以优化 123456789101112131415161718class Solution: def uniquePaths(self, m: int, n: int) -&gt; int: # f = [[0 for _ in range(n)] for _ in range(m)] # f[0][0] = 1 # for i in range(m): # for j in range(n): # if i &gt; 0: # f[i][j] += f[i - 1][j] # if j &gt; 0: # f[i][j] += f[i][j - 1] # return f[m - 1][n - 1] f = [0 for _ in range(n)] f[0] = 1 for i in range(m): for j in range(n): if j &gt; 0: f[j] += f[j - 1] return f[n - 1] 91. 解码方法难度中等343 一条包含字母 A-Z 的消息通过以下方式进行了编码： 1234&apos;A&apos; -&gt; 1&apos;B&apos; -&gt; 2...&apos;Z&apos; -&gt; 26 给定一个只包含数字的非空字符串，请计算解码方法的总数。 12345678910111213141516class Solution: def numDecodings(self, s: str) -&gt; int: # 包含了这个corner case # if not s: # return 0 dp = [0] * (len(s) + 1) dp[0] = 1 for i in range(1, len(s) + 1): t = int(s[i-1]) if 1 &lt;= t and t &lt;= 9: dp[i] = dp[i - 1] if i &gt;= 2: t = int(s[i - 1]) + 10 * int(s[i - 2]) if t&gt;=10 and t&lt;=26: dp[i] += dp[i - 2] return dp[-1] 198. 打家劫舍难度简单736 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。 1234567891011121314class Solution: def rob(self, nums: List[int]) -&gt; int: n = len(nums) if n == 0: return 0 elif n == 1: return nums[0] dp = [0] * n dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) for i in range(2, n): dp[i] = max((dp[i - 2] + nums[i]), dp[i - 1]) return dp[n-1] 1234567891011121314class Solution: def rob(self, nums: List[int]) -&gt; int: if not nums: return 0 n = len(nums) dp = [0] * (n + 1) for i in range(1, n + 1): if i == 1: dp[i] = nums[i - 1] else: dp[i] = dp[i - 1] dp[i] = max(dp[i], dp[i - 2] + nums[i - 1]) return dp[n] 300. 最长上升子序列难度中等629收藏分享切换为英文关注反馈 给定一个无序的整数数组，找到其中最长上升子序列的长度。 解法一python 动态规划12345678910111213class Solution: def lengthOfLIS(self, nums: List[int]) -&gt; int: # 动态规划 # 时间复杂度O(n2) if not nums: return 0 n = len(nums) dp = [1] * n for i in range(n): for j in range(i): if nums[j] &lt; nums[i]: dp[i] = max(dp[i], dp[j] + 1) return max(dp) c++1234567891011121314151617181920class Solution &#123;public: int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); if (len &lt; 1) &#123; return len; &#125; vector&lt;int&gt; dp(len); dp[0] = 1; for (int i = 1; i &lt; len; i++) &#123; for (int j = 0; j &lt; i; j++) &#123; if (nums[i] &gt; nums[j]) &#123; dp[i] = max(dp[i], dp[j] + 1); &#125; &#125; dp[i] = max(dp[i], 1); &#125; return *max_element(dp.begin(), dp.end()); &#125;&#125;; 解法二python 贪心加二分12345678910111213141516171819202122class Solution: def lengthOfLIS(self, nums: List[int]) -&gt; int: # 贪心+二分 # 时间复杂度Onlogn) # dp[i]代表长度为 i 的最长上升子序列的末尾元素的最小值 dp = [] for n in nums: if not dp or n &gt; dp[-1]: dp.append(n) else: l, r = 0, len(dp) - 1 while l &lt; r: mid = l + r + 1&gt;&gt; 1 if dp[mid] &gt;= n: r = mid - 1 else: l = mid if dp[l] &lt; n: dp[l + 1] = n else: dp[l] = n return len(dp) c++12345678910111213141516171819202122232425262728class Solution &#123;public: int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; dp; for (int num : nums) &#123; if (dp.empty() || num &gt; dp.back()) &#123; dp.push_back(num); &#125; else &#123; int l = 0, r = dp.size() - 1; while (l &lt; r) &#123; int mid = (l + r + 1) &gt;&gt; 1; if (dp[mid] &gt;= num) &#123; r = mid - 1; &#125; else &#123; l = mid; &#125; &#125; if (dp[l] &lt; num) &#123; dp[l + 1] = num; &#125; else &#123; dp[l] = num; &#125; &#125; &#125; return dp.size(); &#125;&#125;; 1143. 最长公共子序列难度中等159收藏分享切换为英文关注反馈 给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。 一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。 若这两个字符串没有公共子序列，则返回 0。 c++123456789101112131415161718class Solution &#123;public: int longestCommonSubsequence(string text1, string text2) &#123; int len1 = text1.size(); int len2 = text2.size(); vector&lt;vector&lt;int&gt;&gt; dp(len1 + 1, vector&lt;int&gt; (len2 + 1)); for (int i = 1; i &lt; len1 + 1; i++) &#123; for (int j = 1; j &lt; len2 + 1; j++) &#123; if (text1[i - 1] == text2[j - 1]) &#123; dp[i][j] = dp[i - 1][j - 1] + 1; &#125; else &#123; dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); &#125; &#125; &#125; return dp[len1][len2]; &#125;&#125;; 518. 零钱兑换 II难度中等135 给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 注意和完全背包相似 1234567891011121314151617class Solution: def change(self, amount: int, coins: List[int]) -&gt; int: if amount == 0: return 1 if not coins: return 0 n = len(coins) dp = [[0 for _ in range(amount + 1)] for _ in range(n)] # 此处初始化很重要，思考该怎么初始化，初始化全部为1会出问题 dp[0][0] = 1 for i in range(n): for j in range(0, amount + 1): if j - coins[i] &gt;= 0: dp[i][j] = dp[i][j - coins[i]] if i &gt;= 1: dp[i][j] += dp[i - 1][j] return dp[n - 1][amount] 123456789101112131415class Solution: def change(self, amount: int, coins: List[int]) -&gt; int: if amount == 0: return 1 if not coins: return 0 n = len(coins) dp = [0 for _ in range(amount + 1)] # 此处初始化很重要，思考该怎么初始化，初始化全部为1会出问题 dp[0] = 1 for i in range(n): for j in range(0, amount + 1): if j - coins[i] &gt;= 0: dp[j] += dp[j - coins[i]] return dp[amount] 32. 最长有效括号难度困难826 给定一个只包含 &#39;(&#39; 和 &#39;)&#39; 的字符串，找出最长的包含有效括号的子串的长度。 栈 和20. 有效的括号相似12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: int longestValidParentheses(string s) &#123; stack&lt;int&gt; stk; vector&lt;int&gt; marks(s.length()); int left = 0, len = 0, ans = 0; for (int i = 0; i &lt; s.size(); i++) &#123; if (s[i] == '(') &#123; stk.push(i); &#125; else &#123; // stk中没有匹配的左括号 if (stk.empty()) &#123; marks[i] = 1; // stk中有匹配的左括号，弹出左括号 &#125; else &#123; stk.pop(); &#125; &#125; &#125; // 未匹配的左括号是不需要的，标记 while (!stk.empty()) &#123; marks[stk.top()] = 1; stk.pop(); &#125; for (int i = 0; i &lt; s.size(); i++) &#123; if (marks[i] == 1) &#123; len = 0; continue; &#125; len++; ans = max(ans, len); &#125; return ans; &#125;&#125;; dp 和 300. 最长上升子序列相似1234567891011121314151617181920212223class Solution &#123;public: int longestValidParentheses(string s) &#123; int len = s.size(); if (len == 0) &#123; return 0; &#125; vector&lt;int&gt; dp(len); for (int i = 1; i &lt; len; i++) &#123; if (s[i] == ')') &#123; int pre = i - dp[i - 1] - 1; if (pre &gt;= 0 &amp;&amp; s[pre] == '(') &#123; dp[i] = dp[i - 1] + 2; if (pre &gt; 0) &#123; dp[i] += dp[pre - 1]; &#125; &#125; &#125; &#125; return *max_element(dp.begin(), dp.end()); &#125;&#125;; 44. 通配符匹配难度困难462 给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 &#39;?&#39; 和 &#39;*&#39; 的通配符匹配。 12&apos;?&apos; 可以匹配任何单个字符。&apos;*&apos; 可以匹配任意字符串（包括空字符串）。 两个字符串完全匹配才算匹配成功。 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123;public: bool isMatch(string s, string p) &#123; int m = s.length(); int n = p.length(); vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1)); // 关键在初始化 dp[0][0] = 1; for (int j = 1; j &lt;= n; j++) &#123; if (p[j - 1] == '*') &#123; // 若j-1可以匹配， j就可以匹配 dp[0][j] = dp[0][j - 1]; &#125; &#125; // 对p进行分类讨论，1为小写字母，2为？号，3为*号 // j从1开始，因为后面用到i-1 j-1； // 第一列不用初始化，因为除了dp[0][0],p为空无法和s非空匹配 for (int i = 1; i &lt;= m; i++) &#123; // j从1开始，因为后面用到第一列 for (int j = 1; j &lt;= n; j++) &#123; if (s[i - 1] == p[j - 1] || p[j - 1] == '?') &#123; dp[i][j] = dp[i - 1][j - 1]; &#125; else if (p[j - 1] == '*') &#123; // 1. 不使用*号，dp[i][j]取决于dp[i][j-1] // 2. 使用*号，则p[j-1]至少匹配了s[i-1] // ,此时dp[i][j]只有当dp[i - 1][j]为1，即p[j-1]之前匹配了s[i-1]之前， dp[i][j] = dp[i][j - 1] || dp[i - 1][j]; &#125; &#125; &#125; return dp[m][n] == 1; &#125;&#125;; 剑指 Offer 42. 连续子数组的最大和难度简单91收藏分享切换为英文关注反馈 输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。 要求时间复杂度为O(n)。 1234567891011121314151617181920class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; if (nums.empty()) &#123; return 0; &#125; vector&lt;int&gt; dp(nums.size()); dp[0] = nums[0]; int res = nums[0]; for (int i = 1; i &lt; nums.size(); i++) &#123; if (dp[i - 1] &lt; 0) &#123; dp[i] = nums[i]; &#125; else &#123; dp[i] = dp[i-1] + nums[i]; &#125; res = max(res, dp[i]); &#125; return res; &#125;&#125;; 494. 目标和难度中等329收藏分享切换为英文关注反馈 给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。 返回可以使最终数组和为目标数 S 的所有添加符号的方法数。 123456789101112131415161718192021222324252627class Solution &#123;public: int findTargetSumWays(vector&lt;int&gt;&amp; nums, int S) &#123; // sum(P) - sum(N) = target // sum(P) - sum(N) + sum(P) + sum(Q) = target // 2*sum(P) = target + sum(nums) // G[i][j]:从前i件物品中选取若干件放入容量为j的背包中，使背包刚好能装满的方案数目 int sum = 0; int len = nums.size(); for (int n : nums) &#123; sum += n; &#125; if (sum &lt; S || (sum + S) % 2 == 1) &#123; return 0; &#125; int target = (sum + S) / 2; vector&lt;int&gt; dp(target + 1); dp[0] = 1; for (int i = 1; i &lt;= len; i++) &#123; for (int j = target; j &gt;= nums[i - 1]; j--) &#123; dp[j] += dp[j - nums[i - 1]]; &#125; &#125; return dp[target]; &#125;&#125;; 416. 分割等和子集难度中等340 给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。 123456789101112131415161718192021222324class Solution &#123;public: bool canPartition(vector&lt;int&gt;&amp; nums) &#123; int sum = accumulate(nums.begin(), nums.end(), 0); if (sum % 2 == 1) &#123; return false; &#125; int target = sum / 2; // dp[i][j]:前i个元素，是否存在和为j的组合 vector&lt;vector&lt;int&gt;&gt; dp(nums.size() + 1, vector&lt;int&gt;(target + 1)); // dp[0][0] = 1 dp[0][j] = 0 dp[0][0] = 1; for (int i = 1; i &lt;= nums.size(); i++) &#123; for (int j = 0; j &lt;= target; j++) &#123; dp[i][j] = dp[i - 1][j]; if (j &gt;= nums[i - 1]) &#123; dp[i][j] |= dp[i - 1][j - nums[i - 1]]; &#125; &#125; &#125; return dp[nums.size()][target]; &#125;&#125;; 474. 一和零难度中等184 在计算机界中，我们总是追求用有限的资源获取最大的收益。 现在，假设你分别支配着 m 个 0 和 n 个 1。另外，还有一个仅包含 0 和 1 字符串的数组。 你的任务是使用给定的 m 个 0 和 n 个 1 ，找到能拼出存在于数组中的字符串的最大数量。每个 0 和 1 至多被使用一次。 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: int findMaxForm(vector&lt;string&gt;&amp; strs, int m, int n) &#123; int len = strs.size(); // 把总共的 0 个 1 的个数视为背包的容量，每一个字符串视为装进背包的物品。 // 这道题就可以使用 0-1 背包问题的思路完成。这里的目标值是能放进背包的字符串的数量。 vector&lt; vector&lt; vector&lt;int&gt; &gt; &gt; dp(len + 1, vector&lt;vector&lt;int&gt;&gt;(m + 1, vector&lt;int&gt;(n + 1))); for (int i = 1; i &lt;= len; i++) &#123; vector&lt;int&gt; cnt = countZerosAndOnes(strs[i - 1]); for (int j = 0; j &lt;= m; j++) &#123; for(int k = 0; k&lt;= n; k++) &#123; dp[i][j][k] = dp[i - 1][j][k]; int zeros = cnt[0]; int ones = cnt[1]; if (j &gt;= zeros &amp;&amp; k &gt;= ones) &#123; dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - zeros][k - ones] + 1); &#125; &#125; &#125; &#125; return dp[len][m][n]; &#125; vector&lt;int&gt; countZerosAndOnes(string s) &#123; vector&lt;int&gt; res(2); for (char c : s) &#123; res[c - '0']++; &#125; return res; &#125;&#125;; 546. 移除盒子难度困难140收藏分享切换为英文关注反馈 给出一些不同颜色的盒子，盒子的颜色由数字表示，即不同的数字表示不同的颜色。你将经过若干轮操作去去掉盒子，直到所有的盒子都去掉为止。每一轮你可以移除具有相同颜色的连续 k 个盒子（k &gt;= 1），这样一轮之后你将得到 k*k 个积分。当你将所有盒子都去掉之后，求你能获得的最大积分和。 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123;public: int dp[100][100][100]; int removeBoxes(vector&lt;int&gt;&amp; boxes) &#123; return calculate(boxes, 0, boxes.size() - 1, 0); // dp[i][j][k] &#125; int calculate(vector&lt;int&gt;&amp; boxes, int l, int r, int k) &#123; if (l &gt; r) &#123; return 0; &#125; if (dp[l][r][k] != 0) &#123; return dp[l][r][k]; &#125; while (r &gt; l &amp;&amp; boxes[r] == boxes[r - 1]) &#123; r--; k++; &#125; // 按照boxes[r]元素及后面的元素，和前面那个区间一起消除分情况，取最大 dp[l][r][k] = calculate(boxes, l, r - 1, 0) + (k + 1) * (k + 1); for (int i = l; i &lt; r; i++) &#123; if (boxes[i] == boxes[r]) &#123; dp[l][r][k] = max(dp[l][r][k], calculate(boxes, l, i, k + 1) + calculate(boxes, i + 1, r - 1, 0)); &#125; &#125; return dp[l][r][k]; &#125; //时间复杂度：O(n^4)O(n)。最坏情况下每个 f(l, r, k)f(l,r,k) 被计算一次，每次状态转移需要 O(n)的时间复杂度。 // 空间复杂度：O(n^3)，dp数组的空间代价是 O(n^3)，递归使用栈空间的代价为 O(n)。&#125;; 312. 戳气球难度困难488收藏分享切换为英文关注反馈 有 n 个气球，编号为0 到 n-1，每个气球上都标有一个数字，这些数字存在数组 nums 中。 现在要求你戳破所有的气球。如果你戳破气球 i ，就可以获得 nums[left] * nums[i] * nums[right] 个硬币。 这里的 left 和 right 代表和 i 相邻的两个气球的序号。注意当你戳破了气球 i 后，气球 left 和气球 right 就变成了相邻的气球。 求所能获得硬币的最大数量。 647. 回文子串难度中等314收藏分享切换为英文关注反馈 给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。 具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。 中心扩展法1234567891011121314151617181920212223242526272829class Solution &#123;public: int countSubstrings(string s) &#123; int n = s.size(); int ans = 0; // 回文长度是奇数 for (int i = 0; i &lt; n; i++) &#123; int l = i; int r = i; while (l &gt;= 0 &amp;&amp; r &lt; n &amp;&amp; s[l] == s[r]) &#123; --l; ++r; ++ans; &#125; &#125; // 回文长度是偶数 for (int i = 0; i &lt; n - 1; i++) &#123; int l = i; int r = i + 1; while (l &gt;= 0 &amp;&amp; r &lt; n &amp;&amp; s[l] == s[r]) &#123; --l; ++r; ++ans; &#125; &#125; return ans; &#125;&#125;; 二维DP注意从列开始循环 简单题1002. 查找常用字符难度简单172收藏分享切换为英文接收动态反馈 给定仅有小写字母组成的字符串数组 A，返回列表中的每个字符串中都显示的全部字符（包括重复字符）组成的列表。例如，如果一个字符在每个字符串中出现 3 次，但不是 4 次，则需要在最终答案中包含该字符 3 次。 你可以按任意顺序返回答案。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution &#123;public: vector&lt;string&gt; commonChars(vector&lt;string&gt;&amp; A) &#123; // 每个字符串之间字符数量的交集 vector&lt;string&gt; res; vector&lt;int&gt; num(26); int len = A.size(); if (len == 0) &#123; return res; &#125; for (int i = 0; i &lt; A[0].size(); i++) &#123; num[A[0][i] - 'a']++; &#125; for (int i = 1; i &lt; len; i++) &#123; vector&lt;int&gt; tmp(26); for (int j = 0; j &lt; A[i].size(); j++) &#123; tmp[A[i][j] - 'a']++; &#125; for (int j = 0; j &lt; 26; j++) &#123; if (num[j] &amp;&amp; tmp[j]) &#123; num[j] = min(num[j], tmp[j]); &#125; else &#123; num[j] = 0; &#125; &#125; &#125; for (int j = 0; j &lt; 26; j++) &#123; if (num[j] != 0) &#123; for (int k = 0; k &lt; num[j]; k++) &#123; string s = ""; s += j + 'a'; res.push_back(s); &#125; &#125; &#125; return res; &#125;&#125;; 1234567891011121314151617class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; int dp = nums[0]; int res = nums[0]; for (int i = 1; i &lt; nums.size(); i++) &#123; if (dp &gt;= 0) &#123; dp += nums[i]; &#125; else &#123; dp = nums[i]; &#125; res = max(dp, res); &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hexo博客搭建]]></title>
    <url>%2F2021%2F04%2F18%2Fbuild_blog%2F</url>
    <content type="text"><![CDATA[前言hexo博客搭建记录 记录 安装node.js 安装hexo 12345npm i hexo-cli -ghexo init npm installhexo g hexo server 配置github 配置github pages 配置ssh密钥 1npm install hexo-deployer-git --save 修改_config.yml的deploy配置 1234deploy:- type: git repo: https://github.com/xxx/xxx.github.io.git branch: master 1hexo deploy 使用 在_posts下创建一个md日志 123hexo s #本地查看效果hexo g #生成静态文件hexo d #远端部署 参考 https://www.zhihu.com/search?q=hexo%20github&amp;utm_content=search_history&amp;type=content https://github.com/xulayen/blog]]></content>
      <categories>
        <category>技术杂烩</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vlog教程学习记录]]></title>
    <url>%2F2021%2F04%2F18%2Fvlog%2F</url>
    <content type="text"><![CDATA[前言vlog教程学习记录 记录 设备 便携三角架富图 PIXI+手机夹 博雅 枫笛手机话筒 脚本 参考 https://www.zhihu.com/search?q=hexo%20github&amp;utm_content=search_history&amp;type=content https://github.com/xulayen/blog]]></content>
      <categories>
        <category>技术杂烩</category>
      </categories>
  </entry>
</search>
